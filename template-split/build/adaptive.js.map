{
  "version": 3,
  "file": "/Users/scalvert/Mobify/template-split/build/adaptive.js",
  "sources": [
    "../node_modules/adaptivejs/node_modules/grunt-requirejs/node_modules/almond/almond.js",
    "../vendor/zepto.js",
    "../node_modules/adaptivejs/src/selectorLibrary.js",
    "../node_modules/adaptivejs/node_modules/mobifyjs-utils/utils.js",
    "../build/buildConfig.js",
    "../node_modules/adaptivejs/src/utils.js",
    "../node_modules/adaptivejs/src/logger.js",
    "../node_modules/adaptivejs/src/router.js",
    "../bower_components/imageresize/resizeImages.js",
    "../node_modules/adaptivejs/bower_components/requirejs-plugins/lib/text.js",
    "../node_modules/adaptivejs/bower_components/requirejs-plugins/src/json.js",
    "../package.json!json",
    "../node_modules/adaptivejs/src/defaults.js",
    "views/includes/_header.js",
    "views/includes/_footer.js",
    "../node_modules/adaptivejs/lib/dust-requirejs.js",
    "../bower_components/dustjs-linkedin/dist/dust-core.js",
    "../node_modules/adaptivejs/lib/dustPatch.js",
    "templates/partials/_header!dust",
    "templates/partials/_footer!dust",
    "templates/base!dust",
    "devSettings.js",
    "../node_modules/adaptivejs/lib/settings.js",
    "views/base.js",
    "../bower_components/split-test/dist/split-test.js",
    "templates/home1!dust",
    "templates/home2!dust",
    "templates/home3!dust",
    "views/home.js",
    "router.js",
    "../node_modules/adaptivejs/node_modules/mobifyjs/src/patchAnchorLinks.js",
    "../node_modules/adaptivejs/node_modules/mobifyjs/src/capture.js",
    "../node_modules/adaptivejs/src/adaptive.js",
    "../node_modules/adaptivejs/src/context.js",
    "../node_modules/adaptivejs/src/view.js",
    "main.js"
  ],
  "names": [],
  "mappings": "AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACxaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/zDA,ADg0DA;AC/zDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChCA,ADiCA;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrTA,ADsTA;ACrTA;AACA;AACA;AACA;AACA;AACA,ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChJA,ADiJA;AChJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACzPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnIA,ADoIA;ACnIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChaA;AACA,ACDA;AACA,ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvBA,ADwBA;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACVA,ADWA;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACZA,ADaA;AEbA,ADCA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC90BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACnKA;AACA;ACDA,ADEA;ACDA;ACDA,ADEA;ACDA;ACDA,ADEA;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACXA,ADYA;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrFA,ADsFA;ACrFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/IA;AACA;AACA,ACFA;AACA;AACA,ACFA;AACA;AACA,ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7CA,AD8CA;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACfA,ADgBA;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxIA,ADyIA;ACxIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACrnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC3HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACxGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACzKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "sourcesContent": [
    "/**\n * @license almond 0.2.9 Copyright (c) 2011-2014, The Dojo Foundation All Rights Reserved.\n * Available via the MIT or new BSD license.\n * see: http://github.com/jrburke/almond for details\n */\n//Going sloppy to avoid 'use strict' string cost, but strict practices should\n//be followed.\n/*jslint sloppy: true */\n/*global setTimeout: false */\n\nvar requirejs, require, define;\n(function (undef) {\n    var main, req, makeMap, handlers,\n        defined = {},\n        waiting = {},\n        config = {},\n        defining = {},\n        hasOwn = Object.prototype.hasOwnProperty,\n        aps = [].slice,\n        jsSuffixRegExp = /\\.js$/;\n\n    function hasProp(obj, prop) {\n        return hasOwn.call(obj, prop);\n    }\n\n    /**\n     * Given a relative module name, like ./something, normalize it to\n     * a real name that can be mapped to a path.\n     * @param {String} name the relative name\n     * @param {String} baseName a real name that the name arg is relative\n     * to.\n     * @returns {String} normalized name\n     */\n    function normalize(name, baseName) {\n        var nameParts, nameSegment, mapValue, foundMap, lastIndex,\n            foundI, foundStarMap, starI, i, j, part,\n            baseParts = baseName && baseName.split(\"/\"),\n            map = config.map,\n            starMap = (map && map['*']) || {};\n\n        //Adjust any relative paths.\n        if (name && name.charAt(0) === \".\") {\n            //If have a base name, try to normalize against it,\n            //otherwise, assume it is a top-level require that will\n            //be relative to baseUrl in the end.\n            if (baseName) {\n                //Convert baseName to array, and lop off the last part,\n                //so that . matches that \"directory\" and not name of the baseName's\n                //module. For instance, baseName of \"one/two/three\", maps to\n                //\"one/two/three.js\", but we want the directory, \"one/two\" for\n                //this normalization.\n                baseParts = baseParts.slice(0, baseParts.length - 1);\n                name = name.split('/');\n                lastIndex = name.length - 1;\n\n                // Node .js allowance:\n                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {\n                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');\n                }\n\n                name = baseParts.concat(name);\n\n                //start trimDots\n                for (i = 0; i < name.length; i += 1) {\n                    part = name[i];\n                    if (part === \".\") {\n                        name.splice(i, 1);\n                        i -= 1;\n                    } else if (part === \"..\") {\n                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {\n                            //End of the line. Keep at least one non-dot\n                            //path segment at the front so it can be mapped\n                            //correctly to disk. Otherwise, there is likely\n                            //no path mapping for a path starting with '..'.\n                            //This can still fail, but catches the most reasonable\n                            //uses of ..\n                            break;\n                        } else if (i > 0) {\n                            name.splice(i - 1, 2);\n                            i -= 2;\n                        }\n                    }\n                }\n                //end trimDots\n\n                name = name.join(\"/\");\n            } else if (name.indexOf('./') === 0) {\n                // No baseName, so this is ID is resolved relative\n                // to baseUrl, pull off the leading dot.\n                name = name.substring(2);\n            }\n        }\n\n        //Apply map config if available.\n        if ((baseParts || starMap) && map) {\n            nameParts = name.split('/');\n\n            for (i = nameParts.length; i > 0; i -= 1) {\n                nameSegment = nameParts.slice(0, i).join(\"/\");\n\n                if (baseParts) {\n                    //Find the longest baseName segment match in the config.\n                    //So, do joins on the biggest to smallest lengths of baseParts.\n                    for (j = baseParts.length; j > 0; j -= 1) {\n                        mapValue = map[baseParts.slice(0, j).join('/')];\n\n                        //baseName segment has  config, find if it has one for\n                        //this name.\n                        if (mapValue) {\n                            mapValue = mapValue[nameSegment];\n                            if (mapValue) {\n                                //Match, update name to the new value.\n                                foundMap = mapValue;\n                                foundI = i;\n                                break;\n                            }\n                        }\n                    }\n                }\n\n                if (foundMap) {\n                    break;\n                }\n\n                //Check for a star map match, but just hold on to it,\n                //if there is a shorter segment match later in a matching\n                //config, then favor over this star map.\n                if (!foundStarMap && starMap && starMap[nameSegment]) {\n                    foundStarMap = starMap[nameSegment];\n                    starI = i;\n                }\n            }\n\n            if (!foundMap && foundStarMap) {\n                foundMap = foundStarMap;\n                foundI = starI;\n            }\n\n            if (foundMap) {\n                nameParts.splice(0, foundI, foundMap);\n                name = nameParts.join('/');\n            }\n        }\n\n        return name;\n    }\n\n    function makeRequire(relName, forceSync) {\n        return function () {\n            //A version of a require function that passes a moduleName\n            //value for items that may need to\n            //look up paths relative to the moduleName\n            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));\n        };\n    }\n\n    function makeNormalize(relName) {\n        return function (name) {\n            return normalize(name, relName);\n        };\n    }\n\n    function makeLoad(depName) {\n        return function (value) {\n            defined[depName] = value;\n        };\n    }\n\n    function callDep(name) {\n        if (hasProp(waiting, name)) {\n            var args = waiting[name];\n            delete waiting[name];\n            defining[name] = true;\n            main.apply(undef, args);\n        }\n\n        if (!hasProp(defined, name) && !hasProp(defining, name)) {\n            throw new Error('No ' + name);\n        }\n        return defined[name];\n    }\n\n    //Turns a plugin!resource to [plugin, resource]\n    //with the plugin being undefined if the name\n    //did not have a plugin prefix.\n    function splitPrefix(name) {\n        var prefix,\n            index = name ? name.indexOf('!') : -1;\n        if (index > -1) {\n            prefix = name.substring(0, index);\n            name = name.substring(index + 1, name.length);\n        }\n        return [prefix, name];\n    }\n\n    /**\n     * Makes a name map, normalizing the name, and using a plugin\n     * for normalization if necessary. Grabs a ref to plugin\n     * too, as an optimization.\n     */\n    makeMap = function (name, relName) {\n        var plugin,\n            parts = splitPrefix(name),\n            prefix = parts[0];\n\n        name = parts[1];\n\n        if (prefix) {\n            prefix = normalize(prefix, relName);\n            plugin = callDep(prefix);\n        }\n\n        //Normalize according\n        if (prefix) {\n            if (plugin && plugin.normalize) {\n                name = plugin.normalize(name, makeNormalize(relName));\n            } else {\n                name = normalize(name, relName);\n            }\n        } else {\n            name = normalize(name, relName);\n            parts = splitPrefix(name);\n            prefix = parts[0];\n            name = parts[1];\n            if (prefix) {\n                plugin = callDep(prefix);\n            }\n        }\n\n        //Using ridiculous property names for space reasons\n        return {\n            f: prefix ? prefix + '!' + name : name, //fullName\n            n: name,\n            pr: prefix,\n            p: plugin\n        };\n    };\n\n    function makeConfig(name) {\n        return function () {\n            return (config && config.config && config.config[name]) || {};\n        };\n    }\n\n    handlers = {\n        require: function (name) {\n            return makeRequire(name);\n        },\n        exports: function (name) {\n            var e = defined[name];\n            if (typeof e !== 'undefined') {\n                return e;\n            } else {\n                return (defined[name] = {});\n            }\n        },\n        module: function (name) {\n            return {\n                id: name,\n                uri: '',\n                exports: defined[name],\n                config: makeConfig(name)\n            };\n        }\n    };\n\n    main = function (name, deps, callback, relName) {\n        var cjsModule, depName, ret, map, i,\n            args = [],\n            callbackType = typeof callback,\n            usingExports;\n\n        //Use name if no relName\n        relName = relName || name;\n\n        //Call the callback to define the module, if necessary.\n        if (callbackType === 'undefined' || callbackType === 'function') {\n            //Pull out the defined dependencies and pass the ordered\n            //values to the callback.\n            //Default to [require, exports, module] if no deps\n            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;\n            for (i = 0; i < deps.length; i += 1) {\n                map = makeMap(deps[i], relName);\n                depName = map.f;\n\n                //Fast path CommonJS standard dependencies.\n                if (depName === \"require\") {\n                    args[i] = handlers.require(name);\n                } else if (depName === \"exports\") {\n                    //CommonJS module spec 1.1\n                    args[i] = handlers.exports(name);\n                    usingExports = true;\n                } else if (depName === \"module\") {\n                    //CommonJS module spec 1.1\n                    cjsModule = args[i] = handlers.module(name);\n                } else if (hasProp(defined, depName) ||\n                           hasProp(waiting, depName) ||\n                           hasProp(defining, depName)) {\n                    args[i] = callDep(depName);\n                } else if (map.p) {\n                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});\n                    args[i] = defined[depName];\n                } else {\n                    throw new Error(name + ' missing ' + depName);\n                }\n            }\n\n            ret = callback ? callback.apply(defined[name], args) : undefined;\n\n            if (name) {\n                //If setting exports via \"module\" is in play,\n                //favor that over return value and exports. After that,\n                //favor a non-undefined return value over exports use.\n                if (cjsModule && cjsModule.exports !== undef &&\n                        cjsModule.exports !== defined[name]) {\n                    defined[name] = cjsModule.exports;\n                } else if (ret !== undef || !usingExports) {\n                    //Use the return value from the function.\n                    defined[name] = ret;\n                }\n            }\n        } else if (name) {\n            //May just be an object definition for the module. Only\n            //worry about defining if have a module name.\n            defined[name] = callback;\n        }\n    };\n\n    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {\n        if (typeof deps === \"string\") {\n            if (handlers[deps]) {\n                //callback in this case is really relName\n                return handlers[deps](callback);\n            }\n            //Just return the module wanted. In this scenario, the\n            //deps arg is the module name, and second arg (if passed)\n            //is just the relName.\n            //Normalize module name, if it contains . or ..\n            return callDep(makeMap(deps, callback).f);\n        } else if (!deps.splice) {\n            //deps is a config object, not an array.\n            config = deps;\n            if (config.deps) {\n                req(config.deps, config.callback);\n            }\n            if (!callback) {\n                return;\n            }\n\n            if (callback.splice) {\n                //callback is an array, which means it is a dependency list.\n                //Adjust args if there are dependencies\n                deps = callback;\n                callback = relName;\n                relName = null;\n            } else {\n                deps = undef;\n            }\n        }\n\n        //Support require(['a'])\n        callback = callback || function () {};\n\n        //If relName is a function, it is an errback handler,\n        //so remove it.\n        if (typeof relName === 'function') {\n            relName = forceSync;\n            forceSync = alt;\n        }\n\n        //Simulate async callback;\n        if (forceSync) {\n            main(undef, deps, callback, relName);\n        } else {\n            //Using a non-zero value because of concern for what old browsers\n            //do, and latest browsers \"upgrade\" to 4 if lower value is used:\n            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:\n            //If want a value immediately, use require('id') instead -- something\n            //that works in almond on the global level, but not guaranteed and\n            //unlikely to work in other AMD implementations.\n            setTimeout(function () {\n                main(undef, deps, callback, relName);\n            }, 4);\n        }\n\n        return req;\n    };\n\n    /**\n     * Just drops the config on the floor, but returns req in case\n     * the config return value is used.\n     */\n    req.config = function (cfg) {\n        return req(cfg);\n    };\n\n    /**\n     * Expose module registry for debugging and tooling\n     */\n    requirejs._defined = defined;\n\n    define = function (name, deps, callback) {\n\n        //This module may not have dependencies\n        if (!deps.splice) {\n            //deps is not an array, so probably means\n            //an object literal or factory function for\n            //the value. Adjust args.\n            callback = deps;\n            deps = [];\n        }\n\n        if (!hasProp(defined, name) && !hasProp(waiting, name)) {\n            waiting[name] = [name, deps, callback];\n        }\n    };\n\n    define.amd = {\n        jQuery: true\n    };\n}());\n\ndefine(\"almond\", function(){});\n\n",
    "/* Zepto 1.1.6 - zepto event ajax form fx selector stack data - zeptojs.com/license */\n\nvar Zepto = (function() {\n  var undefined, key, $, classList, emptyArray = [], slice = emptyArray.slice, filter = emptyArray.filter,\n    document = window.document,\n    elementDisplay = {}, classCache = {},\n    cssNumber = { 'column-count': 1, 'columns': 1, 'font-weight': 1, 'line-height': 1,'opacity': 1, 'z-index': 1, 'zoom': 1 },\n    fragmentRE = /^\\s*<(\\w+|!)[^>]*>/,\n    singleTagRE = /^<(\\w+)\\s*\\/?>(?:<\\/\\1>|)$/,\n    tagExpanderRE = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/ig,\n    rootNodeRE = /^(?:body|html)$/i,\n    capitalRE = /([A-Z])/g,\n\n    // special attributes that should be get/set via method calls\n    methodAttributes = ['val', 'css', 'html', 'text', 'data', 'width', 'height', 'offset'],\n\n    adjacencyOperators = [ 'after', 'prepend', 'before', 'append' ],\n    table = document.createElement('table'),\n    tableRow = document.createElement('tr'),\n    containers = {\n      'tr': document.createElement('tbody'),\n      'tbody': table, 'thead': table, 'tfoot': table,\n      'td': tableRow, 'th': tableRow,\n      '*': document.createElement('div')\n    },\n    readyRE = /complete|loaded|interactive/,\n    simpleSelectorRE = /^[\\w-]*$/,\n    class2type = {},\n    toString = class2type.toString,\n    zepto = {},\n    camelize, uniq,\n    tempParent = document.createElement('div'),\n    propMap = {\n      'tabindex': 'tabIndex',\n      'readonly': 'readOnly',\n      'for': 'htmlFor',\n      'class': 'className',\n      'maxlength': 'maxLength',\n      'cellspacing': 'cellSpacing',\n      'cellpadding': 'cellPadding',\n      'rowspan': 'rowSpan',\n      'colspan': 'colSpan',\n      'usemap': 'useMap',\n      'frameborder': 'frameBorder',\n      'contenteditable': 'contentEditable'\n    },\n    isArray = Array.isArray ||\n      function(object){ return object instanceof Array }\n\n  zepto.matches = function(element, selector) {\n    if (!selector || !element || element.nodeType !== 1) return false\n    var matchesSelector = element.webkitMatchesSelector || element.mozMatchesSelector ||\n                          element.oMatchesSelector || element.matchesSelector\n    if (matchesSelector) return matchesSelector.call(element, selector)\n    // fall back to performing a selector:\n    var match, parent = element.parentNode, temp = !parent\n    if (temp) (parent = tempParent).appendChild(element)\n    match = ~zepto.qsa(parent, selector).indexOf(element)\n    temp && tempParent.removeChild(element)\n    return match\n  }\n\n  function type(obj) {\n    return obj == null ? String(obj) :\n      class2type[toString.call(obj)] || \"object\"\n  }\n\n  function isFunction(value) { return type(value) == \"function\" }\n  function isWindow(obj)     { return obj != null && obj == obj.window }\n  function isDocument(obj)   { return obj != null && obj.nodeType == obj.DOCUMENT_NODE }\n  function isObject(obj)     { return type(obj) == \"object\" }\n  function isPlainObject(obj) {\n    return isObject(obj) && !isWindow(obj) && Object.getPrototypeOf(obj) == Object.prototype\n  }\n  function likeArray(obj) { return typeof obj.length == 'number' }\n\n  function compact(array) { return filter.call(array, function(item){ return item != null }) }\n  function flatten(array) { return array.length > 0 ? $.fn.concat.apply([], array) : array }\n  camelize = function(str){ return str.replace(/-+(.)?/g, function(match, chr){ return chr ? chr.toUpperCase() : '' }) }\n  function dasherize(str) {\n    return str.replace(/::/g, '/')\n           .replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2')\n           .replace(/([a-z\\d])([A-Z])/g, '$1_$2')\n           .replace(/_/g, '-')\n           .toLowerCase()\n  }\n  uniq = function(array){ return filter.call(array, function(item, idx){ return array.indexOf(item) == idx }) }\n\n  function classRE(name) {\n    return name in classCache ?\n      classCache[name] : (classCache[name] = new RegExp('(^|\\\\s)' + name + '(\\\\s|$)'))\n  }\n\n  function maybeAddPx(name, value) {\n    return (typeof value == \"number\" && !cssNumber[dasherize(name)]) ? value + \"px\" : value\n  }\n\n  function defaultDisplay(nodeName) {\n    var element, display\n    if (!elementDisplay[nodeName]) {\n      element = document.createElement(nodeName)\n      document.body.appendChild(element)\n      display = getComputedStyle(element, '').getPropertyValue(\"display\")\n      element.parentNode.removeChild(element)\n      display == \"none\" && (display = \"block\")\n      elementDisplay[nodeName] = display\n    }\n    return elementDisplay[nodeName]\n  }\n\n  function children(element) {\n    return 'children' in element ?\n      slice.call(element.children) :\n      $.map(element.childNodes, function(node){ if (node.nodeType == 1) return node })\n  }\n\n  // `$.zepto.fragment` takes a html string and an optional tag name\n  // to generate DOM nodes nodes from the given html string.\n  // The generated DOM nodes are returned as an array.\n  // This function can be overriden in plugins for example to make\n  // it compatible with browsers that don't support the DOM fully.\n  zepto.fragment = function(html, name, properties) {\n    var dom, nodes, container\n\n    // A special case optimization for a single tag\n    if (singleTagRE.test(html)) dom = $(document.createElement(RegExp.$1))\n\n    if (!dom) {\n      if (html.replace) html = html.replace(tagExpanderRE, \"<$1></$2>\")\n      if (name === undefined) name = fragmentRE.test(html) && RegExp.$1\n      if (!(name in containers)) name = '*'\n\n      container = containers[name]\n      container.innerHTML = '' + html\n      dom = $.each(slice.call(container.childNodes), function(){\n        container.removeChild(this)\n      })\n    }\n\n    if (isPlainObject(properties)) {\n      nodes = $(dom)\n      $.each(properties, function(key, value) {\n        if (methodAttributes.indexOf(key) > -1) nodes[key](value)\n        else nodes.attr(key, value)\n      })\n    }\n\n    return dom\n  }\n\n  // `$.zepto.Z` swaps out the prototype of the given `dom` array\n  // of nodes with `$.fn` and thus supplying all the Zepto functions\n  // to the array. Note that `__proto__` is not supported on Internet\n  // Explorer. This method can be overriden in plugins.\n  zepto.Z = function(dom, selector) {\n    dom = dom || []\n    dom.__proto__ = $.fn\n    dom.selector = selector || ''\n    return dom\n  }\n\n  // `$.zepto.isZ` should return `true` if the given object is a Zepto\n  // collection. This method can be overriden in plugins.\n  zepto.isZ = function(object) {\n    return object instanceof zepto.Z\n  }\n\n  // `$.zepto.init` is Zepto's counterpart to jQuery's `$.fn.init` and\n  // takes a CSS selector and an optional context (and handles various\n  // special cases).\n  // This method can be overriden in plugins.\n  zepto.init = function(selector, context) {\n    var dom\n    // If nothing given, return an empty Zepto collection\n    if (!selector) return zepto.Z()\n    // Optimize for string selectors\n    else if (typeof selector == 'string') {\n      selector = selector.trim()\n      // If it's a html fragment, create nodes from it\n      // Note: In both Chrome 21 and Firefox 15, DOM error 12\n      // is thrown if the fragment doesn't begin with <\n      if (selector[0] == '<' && fragmentRE.test(selector))\n        dom = zepto.fragment(selector, RegExp.$1, context), selector = null\n      // If there's a context, create a collection on that context first, and select\n      // nodes from there\n      else if (context !== undefined) return $(context).find(selector)\n      // If it's a CSS selector, use it to select nodes.\n      else dom = zepto.qsa(document, selector)\n    }\n    // If a function is given, call it when the DOM is ready\n    else if (isFunction(selector)) return $(document).ready(selector)\n    // If a Zepto collection is given, just return it\n    else if (zepto.isZ(selector)) return selector\n    else {\n      // normalize array if an array of nodes is given\n      if (isArray(selector)) dom = compact(selector)\n      // Wrap DOM nodes.\n      else if (isObject(selector))\n        dom = [selector], selector = null\n      // If it's a html fragment, create nodes from it\n      else if (fragmentRE.test(selector))\n        dom = zepto.fragment(selector.trim(), RegExp.$1, context), selector = null\n      // If there's a context, create a collection on that context first, and select\n      // nodes from there\n      else if (context !== undefined) return $(context).find(selector)\n      // And last but no least, if it's a CSS selector, use it to select nodes.\n      else dom = zepto.qsa(document, selector)\n    }\n    // create a new Zepto collection from the nodes found\n    return zepto.Z(dom, selector)\n  }\n\n  // `$` will be the base `Zepto` object. When calling this\n  // function just call `$.zepto.init, which makes the implementation\n  // details of selecting nodes and creating Zepto collections\n  // patchable in plugins.\n  $ = function(selector, context){\n    return zepto.init(selector, context)\n  }\n\n  function extend(target, source, deep) {\n    for (key in source)\n      if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {\n        if (isPlainObject(source[key]) && !isPlainObject(target[key]))\n          target[key] = {}\n        if (isArray(source[key]) && !isArray(target[key]))\n          target[key] = []\n        extend(target[key], source[key], deep)\n      }\n      else if (source[key] !== undefined) target[key] = source[key]\n  }\n\n  // Copy all but undefined properties from one or more\n  // objects to the `target` object.\n  $.extend = function(target){\n    var deep, args = slice.call(arguments, 1)\n    if (typeof target == 'boolean') {\n      deep = target\n      target = args.shift()\n    }\n    args.forEach(function(arg){ extend(target, arg, deep) })\n    return target\n  }\n\n  // `$.zepto.qsa` is Zepto's CSS selector implementation which\n  // uses `document.querySelectorAll` and optimizes for some special cases, like `#id`.\n  // This method can be overriden in plugins.\n  zepto.qsa = function(element, selector){\n    var found,\n        maybeID = selector[0] == '#',\n        maybeClass = !maybeID && selector[0] == '.',\n        nameOnly = maybeID || maybeClass ? selector.slice(1) : selector, // Ensure that a 1 char tag name still gets checked\n        isSimple = simpleSelectorRE.test(nameOnly)\n    return (isDocument(element) && isSimple && maybeID) ?\n      ( (found = element.getElementById(nameOnly)) ? [found] : [] ) :\n      (element.nodeType !== 1 && element.nodeType !== 9) ? [] :\n      slice.call(\n        isSimple && !maybeID ?\n          maybeClass ? element.getElementsByClassName(nameOnly) : // If it's simple, it could be a class\n          element.getElementsByTagName(selector) : // Or a tag\n          element.querySelectorAll(selector) // Or it's not simple, and we need to query all\n      )\n  }\n\n  function filtered(nodes, selector) {\n    return selector == null ? $(nodes) : $(nodes).filter(selector)\n  }\n\n  $.contains = document.documentElement.contains ?\n    function(parent, node) {\n      return parent !== node && parent.contains(node)\n    } :\n    function(parent, node) {\n      while (node && (node = node.parentNode))\n        if (node === parent) return true\n      return false\n    }\n\n  function funcArg(context, arg, idx, payload) {\n    return isFunction(arg) ? arg.call(context, idx, payload) : arg\n  }\n\n  function setAttribute(node, name, value) {\n    value == null ? node.removeAttribute(name) : node.setAttribute(name, value)\n  }\n\n  // access className property while respecting SVGAnimatedString\n  function className(node, value){\n    var klass = node.className || '',\n        svg   = klass && klass.baseVal !== undefined\n\n    if (value === undefined) return svg ? klass.baseVal : klass\n    svg ? (klass.baseVal = value) : (node.className = value)\n  }\n\n  // \"true\"  => true\n  // \"false\" => false\n  // \"null\"  => null\n  // \"42\"    => 42\n  // \"42.5\"  => 42.5\n  // \"08\"    => \"08\"\n  // JSON    => parse if valid\n  // String  => self\n  function deserializeValue(value) {\n    try {\n      return value ?\n        value == \"true\" ||\n        ( value == \"false\" ? false :\n          value == \"null\" ? null :\n          +value + \"\" == value ? +value :\n          /^[\\[\\{]/.test(value) ? $.parseJSON(value) :\n          value )\n        : value\n    } catch(e) {\n      return value\n    }\n  }\n\n  $.type = type\n  $.isFunction = isFunction\n  $.isWindow = isWindow\n  $.isArray = isArray\n  $.isPlainObject = isPlainObject\n\n  $.isEmptyObject = function(obj) {\n    var name\n    for (name in obj) return false\n    return true\n  }\n\n  $.inArray = function(elem, array, i){\n    return emptyArray.indexOf.call(array, elem, i)\n  }\n\n  $.camelCase = camelize\n  $.trim = function(str) {\n    return str == null ? \"\" : String.prototype.trim.call(str)\n  }\n\n  // plugin compatibility\n  $.uuid = 0\n  $.support = { }\n  $.expr = { }\n\n  $.map = function(elements, callback){\n    var value, values = [], i, key\n    if (likeArray(elements))\n      for (i = 0; i < elements.length; i++) {\n        value = callback(elements[i], i)\n        if (value != null) values.push(value)\n      }\n    else\n      for (key in elements) {\n        value = callback(elements[key], key)\n        if (value != null) values.push(value)\n      }\n    return flatten(values)\n  }\n\n  $.each = function(elements, callback){\n    var i, key\n    if (likeArray(elements)) {\n      for (i = 0; i < elements.length; i++)\n        if (callback.call(elements[i], i, elements[i]) === false) return elements\n    } else {\n      for (key in elements)\n        if (callback.call(elements[key], key, elements[key]) === false) return elements\n    }\n\n    return elements\n  }\n\n  $.grep = function(elements, callback){\n    return filter.call(elements, callback)\n  }\n\n  if (window.JSON) $.parseJSON = JSON.parse\n\n  // Populate the class2type map\n  $.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"), function(i, name) {\n    class2type[ \"[object \" + name + \"]\" ] = name.toLowerCase()\n  })\n\n  // Define methods that will be available on all\n  // Zepto collections\n  $.fn = {\n    // Because a collection acts like an array\n    // copy over these useful array functions.\n    forEach: emptyArray.forEach,\n    reduce: emptyArray.reduce,\n    push: emptyArray.push,\n    sort: emptyArray.sort,\n    indexOf: emptyArray.indexOf,\n    concat: emptyArray.concat,\n\n    // `map` and `slice` in the jQuery API work differently\n    // from their array counterparts\n    map: function(fn){\n      return $($.map(this, function(el, i){ return fn.call(el, i, el) }))\n    },\n    slice: function(){\n      return $(slice.apply(this, arguments))\n    },\n\n    ready: function(callback){\n      // need to check if document.body exists for IE as that browser reports\n      // document ready when it hasn't yet created the body element\n      if (readyRE.test(document.readyState) && document.body) callback($)\n      else document.addEventListener('DOMContentLoaded', function(){ callback($) }, false)\n      return this\n    },\n    get: function(idx){\n      return idx === undefined ? slice.call(this) : this[idx >= 0 ? idx : idx + this.length]\n    },\n    toArray: function(){ return this.get() },\n    size: function(){\n      return this.length\n    },\n    remove: function(){\n      return this.each(function(){\n        if (this.parentNode != null)\n          this.parentNode.removeChild(this)\n      })\n    },\n    each: function(callback){\n      emptyArray.every.call(this, function(el, idx){\n        return callback.call(el, idx, el) !== false\n      })\n      return this\n    },\n    filter: function(selector){\n      if (isFunction(selector)) return this.not(this.not(selector))\n      return $(filter.call(this, function(element){\n        return zepto.matches(element, selector)\n      }))\n    },\n    add: function(selector,context){\n      return $(uniq(this.concat($(selector,context))))\n    },\n    is: function(selector){\n      return this.length > 0 && zepto.matches(this[0], selector)\n    },\n    not: function(selector){\n      var nodes=[]\n      if (isFunction(selector) && selector.call !== undefined)\n        this.each(function(idx){\n          if (!selector.call(this,idx)) nodes.push(this)\n        })\n      else {\n        var excludes = typeof selector == 'string' ? this.filter(selector) :\n          (likeArray(selector) && isFunction(selector.item)) ? slice.call(selector) : $(selector)\n        this.forEach(function(el){\n          if (excludes.indexOf(el) < 0) nodes.push(el)\n        })\n      }\n      return $(nodes)\n    },\n    has: function(selector){\n      return this.filter(function(){\n        return isObject(selector) ?\n          $.contains(this, selector) :\n          $(this).find(selector).size()\n      })\n    },\n    eq: function(idx){\n      return idx === -1 ? this.slice(idx) : this.slice(idx, + idx + 1)\n    },\n    first: function(){\n      var el = this[0]\n      return el && !isObject(el) ? el : $(el)\n    },\n    last: function(){\n      var el = this[this.length - 1]\n      return el && !isObject(el) ? el : $(el)\n    },\n    find: function(selector){\n      var result, $this = this\n      if (!selector) result = $()\n      else if (typeof selector == 'object')\n        result = $(selector).filter(function(){\n          var node = this\n          return emptyArray.some.call($this, function(parent){\n            return $.contains(parent, node)\n          })\n        })\n      else if (this.length == 1) result = $(zepto.qsa(this[0], selector))\n      else result = this.map(function(){ return zepto.qsa(this, selector) })\n      return result\n    },\n    closest: function(selector, context){\n      var node = this[0], collection = false\n      if (typeof selector == 'object') collection = $(selector)\n      while (node && !(collection ? collection.indexOf(node) >= 0 : zepto.matches(node, selector)))\n        node = node !== context && !isDocument(node) && node.parentNode\n      return $(node)\n    },\n    parents: function(selector){\n      var ancestors = [], nodes = this\n      while (nodes.length > 0)\n        nodes = $.map(nodes, function(node){\n          if ((node = node.parentNode) && !isDocument(node) && ancestors.indexOf(node) < 0) {\n            ancestors.push(node)\n            return node\n          }\n        })\n      return filtered(ancestors, selector)\n    },\n    parent: function(selector){\n      return filtered(uniq(this.pluck('parentNode')), selector)\n    },\n    children: function(selector){\n      return filtered(this.map(function(){ return children(this) }), selector)\n    },\n    contents: function() {\n      return this.map(function() { return slice.call(this.childNodes) })\n    },\n    siblings: function(selector){\n      return filtered(this.map(function(i, el){\n        return filter.call(children(el.parentNode), function(child){ return child!==el })\n      }), selector)\n    },\n    empty: function(){\n      return this.each(function(){ this.innerHTML = '' })\n    },\n    // `pluck` is borrowed from Prototype.js\n    pluck: function(property){\n      return $.map(this, function(el){ return el[property] })\n    },\n    show: function(){\n      return this.each(function(){\n        this.style.display == \"none\" && (this.style.display = '')\n        if (getComputedStyle(this, '').getPropertyValue(\"display\") == \"none\")\n          this.style.display = defaultDisplay(this.nodeName)\n      })\n    },\n    replaceWith: function(newContent){\n      return this.before(newContent).remove()\n    },\n    wrap: function(structure){\n      var func = isFunction(structure)\n      if (this[0] && !func)\n        var dom   = $(structure).get(0),\n            clone = dom.parentNode || this.length > 1\n\n      return this.each(function(index){\n        $(this).wrapAll(\n          func ? structure.call(this, index) :\n            clone ? dom.cloneNode(true) : dom\n        )\n      })\n    },\n    wrapAll: function(structure){\n      if (this[0]) {\n        $(this[0]).before(structure = $(structure))\n        var children\n        // drill down to the inmost element\n        while ((children = structure.children()).length) structure = children.first()\n        $(structure).append(this)\n      }\n      return this\n    },\n    wrapInner: function(structure){\n      var func = isFunction(structure)\n      return this.each(function(index){\n        var self = $(this), contents = self.contents(),\n            dom  = func ? structure.call(this, index) : structure\n        contents.length ? contents.wrapAll(dom) : self.append(dom)\n      })\n    },\n    unwrap: function(){\n      this.parent().each(function(){\n        $(this).replaceWith($(this).children())\n      })\n      return this\n    },\n    clone: function(){\n      return this.map(function(){ return this.cloneNode(true) })\n    },\n    hide: function(){\n      return this.css(\"display\", \"none\")\n    },\n    toggle: function(setting){\n      return this.each(function(){\n        var el = $(this)\n        ;(setting === undefined ? el.css(\"display\") == \"none\" : setting) ? el.show() : el.hide()\n      })\n    },\n    prev: function(selector){ return $(this.pluck('previousElementSibling')).filter(selector || '*') },\n    next: function(selector){ return $(this.pluck('nextElementSibling')).filter(selector || '*') },\n    html: function(html){\n      return 0 in arguments ?\n        this.each(function(idx){\n          var originHtml = this.innerHTML\n          $(this).empty().append( funcArg(this, html, idx, originHtml) )\n        }) :\n        (0 in this ? this[0].innerHTML : null)\n    },\n    text: function(text){\n      return 0 in arguments ?\n        this.each(function(idx){\n          var newText = funcArg(this, text, idx, this.textContent)\n          this.textContent = newText == null ? '' : ''+newText\n        }) :\n        (0 in this ? this[0].textContent : null)\n    },\n    attr: function(name, value){\n      var result\n      return (typeof name == 'string' && !(1 in arguments)) ?\n        (!this.length || this[0].nodeType !== 1 ? undefined :\n          (!(result = this[0].getAttribute(name)) && name in this[0]) ? this[0][name] : result\n        ) :\n        this.each(function(idx){\n          if (this.nodeType !== 1) return\n          if (isObject(name)) for (key in name) setAttribute(this, key, name[key])\n          else setAttribute(this, name, funcArg(this, value, idx, this.getAttribute(name)))\n        })\n    },\n    removeAttr: function(name){\n      return this.each(function(){ this.nodeType === 1 && name.split(' ').forEach(function(attribute){\n        setAttribute(this, attribute)\n      }, this)})\n    },\n    prop: function(name, value){\n      name = propMap[name] || name\n      return (1 in arguments) ?\n        this.each(function(idx){\n          this[name] = funcArg(this, value, idx, this[name])\n        }) :\n        (this[0] && this[0][name])\n    },\n    data: function(name, value){\n      var attrName = 'data-' + name.replace(capitalRE, '-$1').toLowerCase()\n\n      var data = (1 in arguments) ?\n        this.attr(attrName, value) :\n        this.attr(attrName)\n\n      return data !== null ? deserializeValue(data) : undefined\n    },\n    val: function(value){\n      return 0 in arguments ?\n        this.each(function(idx){\n          this.value = funcArg(this, value, idx, this.value)\n        }) :\n        (this[0] && (this[0].multiple ?\n           $(this[0]).find('option').filter(function(){ return this.selected }).pluck('value') :\n           this[0].value)\n        )\n    },\n    offset: function(coordinates){\n      if (coordinates) return this.each(function(index){\n        var $this = $(this),\n            coords = funcArg(this, coordinates, index, $this.offset()),\n            parentOffset = $this.offsetParent().offset(),\n            props = {\n              top:  coords.top  - parentOffset.top,\n              left: coords.left - parentOffset.left\n            }\n\n        if ($this.css('position') == 'static') props['position'] = 'relative'\n        $this.css(props)\n      })\n      if (!this.length) return null\n      var obj = this[0].getBoundingClientRect()\n      return {\n        left: obj.left + window.pageXOffset,\n        top: obj.top + window.pageYOffset,\n        width: Math.round(obj.width),\n        height: Math.round(obj.height)\n      }\n    },\n    css: function(property, value){\n      if (arguments.length < 2) {\n        var computedStyle, element = this[0]\n        if(!element) return\n        computedStyle = getComputedStyle(element, '')\n        if (typeof property == 'string')\n          return element.style[camelize(property)] || computedStyle.getPropertyValue(property)\n        else if (isArray(property)) {\n          var props = {}\n          $.each(property, function(_, prop){\n            props[prop] = (element.style[camelize(prop)] || computedStyle.getPropertyValue(prop))\n          })\n          return props\n        }\n      }\n\n      var css = ''\n      if (type(property) == 'string') {\n        if (!value && value !== 0)\n          this.each(function(){ this.style.removeProperty(dasherize(property)) })\n        else\n          css = dasherize(property) + \":\" + maybeAddPx(property, value)\n      } else {\n        for (key in property)\n          if (!property[key] && property[key] !== 0)\n            this.each(function(){ this.style.removeProperty(dasherize(key)) })\n          else\n            css += dasherize(key) + ':' + maybeAddPx(key, property[key]) + ';'\n      }\n\n      return this.each(function(){ this.style.cssText += ';' + css })\n    },\n    index: function(element){\n      return element ? this.indexOf($(element)[0]) : this.parent().children().indexOf(this[0])\n    },\n    hasClass: function(name){\n      if (!name) return false\n      return emptyArray.some.call(this, function(el){\n        return this.test(className(el))\n      }, classRE(name))\n    },\n    addClass: function(name){\n      if (!name) return this\n      return this.each(function(idx){\n        if (!('className' in this)) return\n        classList = []\n        var cls = className(this), newName = funcArg(this, name, idx, cls)\n        newName.split(/\\s+/g).forEach(function(klass){\n          if (!$(this).hasClass(klass)) classList.push(klass)\n        }, this)\n        classList.length && className(this, cls + (cls ? \" \" : \"\") + classList.join(\" \"))\n      })\n    },\n    removeClass: function(name){\n      return this.each(function(idx){\n        if (!('className' in this)) return\n        if (name === undefined) return className(this, '')\n        classList = className(this)\n        funcArg(this, name, idx, classList).split(/\\s+/g).forEach(function(klass){\n          classList = classList.replace(classRE(klass), \" \")\n        })\n        className(this, classList.trim())\n      })\n    },\n    toggleClass: function(name, when){\n      if (!name) return this\n      return this.each(function(idx){\n        var $this = $(this), names = funcArg(this, name, idx, className(this))\n        names.split(/\\s+/g).forEach(function(klass){\n          (when === undefined ? !$this.hasClass(klass) : when) ?\n            $this.addClass(klass) : $this.removeClass(klass)\n        })\n      })\n    },\n    scrollTop: function(value){\n      if (!this.length) return\n      var hasScrollTop = 'scrollTop' in this[0]\n      if (value === undefined) return hasScrollTop ? this[0].scrollTop : this[0].pageYOffset\n      return this.each(hasScrollTop ?\n        function(){ this.scrollTop = value } :\n        function(){ this.scrollTo(this.scrollX, value) })\n    },\n    scrollLeft: function(value){\n      if (!this.length) return\n      var hasScrollLeft = 'scrollLeft' in this[0]\n      if (value === undefined) return hasScrollLeft ? this[0].scrollLeft : this[0].pageXOffset\n      return this.each(hasScrollLeft ?\n        function(){ this.scrollLeft = value } :\n        function(){ this.scrollTo(value, this.scrollY) })\n    },\n    position: function() {\n      if (!this.length) return\n\n      var elem = this[0],\n        // Get *real* offsetParent\n        offsetParent = this.offsetParent(),\n        // Get correct offsets\n        offset       = this.offset(),\n        parentOffset = rootNodeRE.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset()\n\n      // Subtract element margins\n      // note: when an element has margin: auto the offsetLeft and marginLeft\n      // are the same in Safari causing offset.left to incorrectly be 0\n      offset.top  -= parseFloat( $(elem).css('margin-top') ) || 0\n      offset.left -= parseFloat( $(elem).css('margin-left') ) || 0\n\n      // Add offsetParent borders\n      parentOffset.top  += parseFloat( $(offsetParent[0]).css('border-top-width') ) || 0\n      parentOffset.left += parseFloat( $(offsetParent[0]).css('border-left-width') ) || 0\n\n      // Subtract the two offsets\n      return {\n        top:  offset.top  - parentOffset.top,\n        left: offset.left - parentOffset.left\n      }\n    },\n    offsetParent: function() {\n      return this.map(function(){\n        var parent = this.offsetParent || document.body\n        while (parent && !rootNodeRE.test(parent.nodeName) && $(parent).css(\"position\") == \"static\")\n          parent = parent.offsetParent\n        return parent\n      })\n    }\n  }\n\n  // for now\n  $.fn.detach = $.fn.remove\n\n  // Generate the `width` and `height` functions\n  ;['width', 'height'].forEach(function(dimension){\n    var dimensionProperty =\n      dimension.replace(/./, function(m){ return m[0].toUpperCase() })\n\n    $.fn[dimension] = function(value){\n      var offset, el = this[0]\n      if (value === undefined) return isWindow(el) ? el['inner' + dimensionProperty] :\n        isDocument(el) ? el.documentElement['scroll' + dimensionProperty] :\n        (offset = this.offset()) && offset[dimension]\n      else return this.each(function(idx){\n        el = $(this)\n        el.css(dimension, funcArg(this, value, idx, el[dimension]()))\n      })\n    }\n  })\n\n  function traverseNode(node, fun) {\n    fun(node)\n    for (var i = 0, len = node.childNodes.length; i < len; i++)\n      traverseNode(node.childNodes[i], fun)\n  }\n\n  // Generate the `after`, `prepend`, `before`, `append`,\n  // `insertAfter`, `insertBefore`, `appendTo`, and `prependTo` methods.\n  adjacencyOperators.forEach(function(operator, operatorIndex) {\n    var inside = operatorIndex % 2 //=> prepend, append\n\n    $.fn[operator] = function(){\n      // arguments can be nodes, arrays of nodes, Zepto objects and HTML strings\n      var argType, nodes = $.map(arguments, function(arg) {\n            argType = type(arg)\n            return argType == \"object\" || argType == \"array\" || arg == null ?\n              arg : zepto.fragment(arg)\n          }),\n          parent, copyByClone = this.length > 1\n      if (nodes.length < 1) return this\n\n      return this.each(function(_, target){\n        parent = inside ? target : target.parentNode\n\n        // convert all methods to a \"before\" operation\n        target = operatorIndex == 0 ? target.nextSibling :\n                 operatorIndex == 1 ? target.firstChild :\n                 operatorIndex == 2 ? target :\n                 null\n\n        var parentInDocument = $.contains(document.documentElement, parent)\n\n        nodes.forEach(function(node){\n          if (copyByClone) node = node.cloneNode(true)\n          else if (!parent) return $(node).remove()\n\n          parent.insertBefore(node, target)\n          if (parentInDocument) traverseNode(node, function(el){\n            if (el.nodeName != null && el.nodeName.toUpperCase() === 'SCRIPT' &&\n               (!el.type || el.type === 'text/javascript') && !el.src)\n              window['eval'].call(window, el.innerHTML)\n          })\n        })\n      })\n    }\n\n    // after    => insertAfter\n    // prepend  => prependTo\n    // before   => insertBefore\n    // append   => appendTo\n    $.fn[inside ? operator+'To' : 'insert'+(operatorIndex ? 'Before' : 'After')] = function(html){\n      $(html)[operator](this)\n      return this\n    }\n  })\n\n  zepto.Z.prototype = $.fn\n\n  // Export internal API functions in the `$.zepto` namespace\n  zepto.uniq = uniq\n  zepto.deserializeValue = deserializeValue\n  $.zepto = zepto\n\n  return $\n})()\n\nwindow.Zepto = Zepto\nwindow.$ === undefined && (window.$ = Zepto)\n\n;(function($){\n  var _zid = 1, undefined,\n      slice = Array.prototype.slice,\n      isFunction = $.isFunction,\n      isString = function(obj){ return typeof obj == 'string' },\n      handlers = {},\n      specialEvents={},\n      focusinSupported = 'onfocusin' in window,\n      focus = { focus: 'focusin', blur: 'focusout' },\n      hover = { mouseenter: 'mouseover', mouseleave: 'mouseout' }\n\n  specialEvents.click = specialEvents.mousedown = specialEvents.mouseup = specialEvents.mousemove = 'MouseEvents'\n\n  function zid(element) {\n    return element._zid || (element._zid = _zid++)\n  }\n  function findHandlers(element, event, fn, selector) {\n    event = parse(event)\n    if (event.ns) var matcher = matcherFor(event.ns)\n    return (handlers[zid(element)] || []).filter(function(handler) {\n      return handler\n        && (!event.e  || handler.e == event.e)\n        && (!event.ns || matcher.test(handler.ns))\n        && (!fn       || zid(handler.fn) === zid(fn))\n        && (!selector || handler.sel == selector)\n    })\n  }\n  function parse(event) {\n    var parts = ('' + event).split('.')\n    return {e: parts[0], ns: parts.slice(1).sort().join(' ')}\n  }\n  function matcherFor(ns) {\n    return new RegExp('(?:^| )' + ns.replace(' ', ' .* ?') + '(?: |$)')\n  }\n\n  function eventCapture(handler, captureSetting) {\n    return handler.del &&\n      (!focusinSupported && (handler.e in focus)) ||\n      !!captureSetting\n  }\n\n  function realEvent(type) {\n    return hover[type] || (focusinSupported && focus[type]) || type\n  }\n\n  function add(element, events, fn, data, selector, delegator, capture){\n    var id = zid(element), set = (handlers[id] || (handlers[id] = []))\n    events.split(/\\s/).forEach(function(event){\n      if (event == 'ready') return $(document).ready(fn)\n      var handler   = parse(event)\n      handler.fn    = fn\n      handler.sel   = selector\n      // emulate mouseenter, mouseleave\n      if (handler.e in hover) fn = function(e){\n        var related = e.relatedTarget\n        if (!related || (related !== this && !$.contains(this, related)))\n          return handler.fn.apply(this, arguments)\n      }\n      handler.del   = delegator\n      var callback  = delegator || fn\n      handler.proxy = function(e){\n        e = compatible(e)\n        if (e.isImmediatePropagationStopped()) return\n        e.data = data\n        var result = callback.apply(element, e._args == undefined ? [e] : [e].concat(e._args))\n        if (result === false) e.preventDefault(), e.stopPropagation()\n        return result\n      }\n      handler.i = set.length\n      set.push(handler)\n      if ('addEventListener' in element)\n        element.addEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture))\n    })\n  }\n  function remove(element, events, fn, selector, capture){\n    var id = zid(element)\n    ;(events || '').split(/\\s/).forEach(function(event){\n      findHandlers(element, event, fn, selector).forEach(function(handler){\n        delete handlers[id][handler.i]\n      if ('removeEventListener' in element)\n        element.removeEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture))\n      })\n    })\n  }\n\n  $.event = { add: add, remove: remove }\n\n  $.proxy = function(fn, context) {\n    var args = (2 in arguments) && slice.call(arguments, 2)\n    if (isFunction(fn)) {\n      var proxyFn = function(){ return fn.apply(context, args ? args.concat(slice.call(arguments)) : arguments) }\n      proxyFn._zid = zid(fn)\n      return proxyFn\n    } else if (isString(context)) {\n      if (args) {\n        args.unshift(fn[context], fn)\n        return $.proxy.apply(null, args)\n      } else {\n        return $.proxy(fn[context], fn)\n      }\n    } else {\n      throw new TypeError(\"expected function\")\n    }\n  }\n\n  $.fn.bind = function(event, data, callback){\n    return this.on(event, data, callback)\n  }\n  $.fn.unbind = function(event, callback){\n    return this.off(event, callback)\n  }\n  $.fn.one = function(event, selector, data, callback){\n    return this.on(event, selector, data, callback, 1)\n  }\n\n  var returnTrue = function(){return true},\n      returnFalse = function(){return false},\n      ignoreProperties = /^([A-Z]|returnValue$|layer[XY]$)/,\n      eventMethods = {\n        preventDefault: 'isDefaultPrevented',\n        stopImmediatePropagation: 'isImmediatePropagationStopped',\n        stopPropagation: 'isPropagationStopped'\n      }\n\n  function compatible(event, source) {\n    if (source || !event.isDefaultPrevented) {\n      source || (source = event)\n\n      $.each(eventMethods, function(name, predicate) {\n        var sourceMethod = source[name]\n        event[name] = function(){\n          this[predicate] = returnTrue\n          return sourceMethod && sourceMethod.apply(source, arguments)\n        }\n        event[predicate] = returnFalse\n      })\n\n      if (source.defaultPrevented !== undefined ? source.defaultPrevented :\n          'returnValue' in source ? source.returnValue === false :\n          source.getPreventDefault && source.getPreventDefault())\n        event.isDefaultPrevented = returnTrue\n    }\n    return event\n  }\n\n  function createProxy(event) {\n    var key, proxy = { originalEvent: event }\n    for (key in event)\n      if (!ignoreProperties.test(key) && event[key] !== undefined) proxy[key] = event[key]\n\n    return compatible(proxy, event)\n  }\n\n  $.fn.delegate = function(selector, event, callback){\n    return this.on(event, selector, callback)\n  }\n  $.fn.undelegate = function(selector, event, callback){\n    return this.off(event, selector, callback)\n  }\n\n  $.fn.live = function(event, callback){\n    $(document.body).delegate(this.selector, event, callback)\n    return this\n  }\n  $.fn.die = function(event, callback){\n    $(document.body).undelegate(this.selector, event, callback)\n    return this\n  }\n\n  $.fn.on = function(event, selector, data, callback, one){\n    var autoRemove, delegator, $this = this\n    if (event && !isString(event)) {\n      $.each(event, function(type, fn){\n        $this.on(type, selector, data, fn, one)\n      })\n      return $this\n    }\n\n    if (!isString(selector) && !isFunction(callback) && callback !== false)\n      callback = data, data = selector, selector = undefined\n    if (isFunction(data) || data === false)\n      callback = data, data = undefined\n\n    if (callback === false) callback = returnFalse\n\n    return $this.each(function(_, element){\n      if (one) autoRemove = function(e){\n        remove(element, e.type, callback)\n        return callback.apply(this, arguments)\n      }\n\n      if (selector) delegator = function(e){\n        var evt, match = $(e.target).closest(selector, element).get(0)\n        if (match && match !== element) {\n          evt = $.extend(createProxy(e), {currentTarget: match, liveFired: element})\n          return (autoRemove || callback).apply(match, [evt].concat(slice.call(arguments, 1)))\n        }\n      }\n\n      add(element, event, callback, data, selector, delegator || autoRemove)\n    })\n  }\n  $.fn.off = function(event, selector, callback){\n    var $this = this\n    if (event && !isString(event)) {\n      $.each(event, function(type, fn){\n        $this.off(type, selector, fn)\n      })\n      return $this\n    }\n\n    if (!isString(selector) && !isFunction(callback) && callback !== false)\n      callback = selector, selector = undefined\n\n    if (callback === false) callback = returnFalse\n\n    return $this.each(function(){\n      remove(this, event, callback, selector)\n    })\n  }\n\n  $.fn.trigger = function(event, args){\n    event = (isString(event) || $.isPlainObject(event)) ? $.Event(event) : compatible(event)\n    event._args = args\n    return this.each(function(){\n      // handle focus(), blur() by calling them directly\n      if (event.type in focus && typeof this[event.type] == \"function\") this[event.type]()\n      // items in the collection might not be DOM elements\n      else if ('dispatchEvent' in this) this.dispatchEvent(event)\n      else $(this).triggerHandler(event, args)\n    })\n  }\n\n  // triggers event handlers on current element just as if an event occurred,\n  // doesn't trigger an actual event, doesn't bubble\n  $.fn.triggerHandler = function(event, args){\n    var e, result\n    this.each(function(i, element){\n      e = createProxy(isString(event) ? $.Event(event) : event)\n      e._args = args\n      e.target = element\n      $.each(findHandlers(element, event.type || event), function(i, handler){\n        result = handler.proxy(e)\n        if (e.isImmediatePropagationStopped()) return false\n      })\n    })\n    return result\n  }\n\n  // shortcut methods for `.bind(event, fn)` for each event type\n  ;('focusin focusout focus blur load resize scroll unload click dblclick '+\n  'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave '+\n  'change select keydown keypress keyup error').split(' ').forEach(function(event) {\n    $.fn[event] = function(callback) {\n      return (0 in arguments) ?\n        this.bind(event, callback) :\n        this.trigger(event)\n    }\n  })\n\n  $.Event = function(type, props) {\n    if (!isString(type)) props = type, type = props.type\n    var event = document.createEvent(specialEvents[type] || 'Events'), bubbles = true\n    if (props) for (var name in props) (name == 'bubbles') ? (bubbles = !!props[name]) : (event[name] = props[name])\n    event.initEvent(type, bubbles, true)\n    return compatible(event)\n  }\n\n})(Zepto)\n\n;(function($){\n  var jsonpID = 0,\n      document = window.document,\n      key,\n      name,\n      rscript = /<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi,\n      scriptTypeRE = /^(?:text|application)\\/javascript/i,\n      xmlTypeRE = /^(?:text|application)\\/xml/i,\n      jsonType = 'application/json',\n      htmlType = 'text/html',\n      blankRE = /^\\s*$/,\n      originAnchor = document.createElement('a')\n\n  originAnchor.href = window.location.href\n\n  // trigger a custom event and return false if it was cancelled\n  function triggerAndReturn(context, eventName, data) {\n    var event = $.Event(eventName)\n    $(context).trigger(event, data)\n    return !event.isDefaultPrevented()\n  }\n\n  // trigger an Ajax \"global\" event\n  function triggerGlobal(settings, context, eventName, data) {\n    if (settings.global) return triggerAndReturn(context || document, eventName, data)\n  }\n\n  // Number of active Ajax requests\n  $.active = 0\n\n  function ajaxStart(settings) {\n    if (settings.global && $.active++ === 0) triggerGlobal(settings, null, 'ajaxStart')\n  }\n  function ajaxStop(settings) {\n    if (settings.global && !(--$.active)) triggerGlobal(settings, null, 'ajaxStop')\n  }\n\n  // triggers an extra global event \"ajaxBeforeSend\" that's like \"ajaxSend\" but cancelable\n  function ajaxBeforeSend(xhr, settings) {\n    var context = settings.context\n    if (settings.beforeSend.call(context, xhr, settings) === false ||\n        triggerGlobal(settings, context, 'ajaxBeforeSend', [xhr, settings]) === false)\n      return false\n\n    triggerGlobal(settings, context, 'ajaxSend', [xhr, settings])\n  }\n  function ajaxSuccess(data, xhr, settings, deferred) {\n    var context = settings.context, status = 'success'\n    settings.success.call(context, data, status, xhr)\n    if (deferred) deferred.resolveWith(context, [data, status, xhr])\n    triggerGlobal(settings, context, 'ajaxSuccess', [xhr, settings, data])\n    ajaxComplete(status, xhr, settings)\n  }\n  // type: \"timeout\", \"error\", \"abort\", \"parsererror\"\n  function ajaxError(error, type, xhr, settings, deferred) {\n    var context = settings.context\n    settings.error.call(context, xhr, type, error)\n    if (deferred) deferred.rejectWith(context, [xhr, type, error])\n    triggerGlobal(settings, context, 'ajaxError', [xhr, settings, error || type])\n    ajaxComplete(type, xhr, settings)\n  }\n  // status: \"success\", \"notmodified\", \"error\", \"timeout\", \"abort\", \"parsererror\"\n  function ajaxComplete(status, xhr, settings) {\n    var context = settings.context\n    settings.complete.call(context, xhr, status)\n    triggerGlobal(settings, context, 'ajaxComplete', [xhr, settings])\n    ajaxStop(settings)\n  }\n\n  // Empty function, used as default callback\n  function empty() {}\n\n  $.ajaxJSONP = function(options, deferred){\n    if (!('type' in options)) return $.ajax(options)\n\n    var _callbackName = options.jsonpCallback,\n      callbackName = ($.isFunction(_callbackName) ?\n        _callbackName() : _callbackName) || ('jsonp' + (++jsonpID)),\n      script = document.createElement('script'),\n      originalCallback = window[callbackName],\n      responseData,\n      abort = function(errorType) {\n        $(script).triggerHandler('error', errorType || 'abort')\n      },\n      xhr = { abort: abort }, abortTimeout\n\n    if (deferred) deferred.promise(xhr)\n\n    $(script).on('load error', function(e, errorType){\n      clearTimeout(abortTimeout)\n      $(script).off().remove()\n\n      if (e.type == 'error' || !responseData) {\n        ajaxError(null, errorType || 'error', xhr, options, deferred)\n      } else {\n        ajaxSuccess(responseData[0], xhr, options, deferred)\n      }\n\n      window[callbackName] = originalCallback\n      if (responseData && $.isFunction(originalCallback))\n        originalCallback(responseData[0])\n\n      originalCallback = responseData = undefined\n    })\n\n    if (ajaxBeforeSend(xhr, options) === false) {\n      abort('abort')\n      return xhr\n    }\n\n    window[callbackName] = function(){\n      responseData = arguments\n    }\n\n    script.src = options.url.replace(/\\?(.+)=\\?/, '?$1=' + callbackName)\n    document.head.appendChild(script)\n\n    if (options.timeout > 0) abortTimeout = setTimeout(function(){\n      abort('timeout')\n    }, options.timeout)\n\n    return xhr\n  }\n\n  $.ajaxSettings = {\n    // Default type of request\n    type: 'GET',\n    // Callback that is executed before request\n    beforeSend: empty,\n    // Callback that is executed if the request succeeds\n    success: empty,\n    // Callback that is executed the the server drops error\n    error: empty,\n    // Callback that is executed on request complete (both: error and success)\n    complete: empty,\n    // The context for the callbacks\n    context: null,\n    // Whether to trigger \"global\" Ajax events\n    global: true,\n    // Transport\n    xhr: function () {\n      return new window.XMLHttpRequest()\n    },\n    // MIME types mapping\n    // IIS returns Javascript as \"application/x-javascript\"\n    accepts: {\n      script: 'text/javascript, application/javascript, application/x-javascript',\n      json:   jsonType,\n      xml:    'application/xml, text/xml',\n      html:   htmlType,\n      text:   'text/plain'\n    },\n    // Whether the request is to another domain\n    crossDomain: false,\n    // Default timeout\n    timeout: 0,\n    // Whether data should be serialized to string\n    processData: true,\n    // Whether the browser should be allowed to cache GET responses\n    cache: true\n  }\n\n  function mimeToDataType(mime) {\n    if (mime) mime = mime.split(';', 2)[0]\n    return mime && ( mime == htmlType ? 'html' :\n      mime == jsonType ? 'json' :\n      scriptTypeRE.test(mime) ? 'script' :\n      xmlTypeRE.test(mime) && 'xml' ) || 'text'\n  }\n\n  function appendQuery(url, query) {\n    if (query == '') return url\n    return (url + '&' + query).replace(/[&?]{1,2}/, '?')\n  }\n\n  // serialize payload and append it to the URL for GET requests\n  function serializeData(options) {\n    if (options.processData && options.data && $.type(options.data) != \"string\")\n      options.data = $.param(options.data, options.traditional)\n    if (options.data && (!options.type || options.type.toUpperCase() == 'GET'))\n      options.url = appendQuery(options.url, options.data), options.data = undefined\n  }\n\n  $.ajax = function(options){\n    var settings = $.extend({}, options || {}),\n        deferred = $.Deferred && $.Deferred(),\n        urlAnchor\n    for (key in $.ajaxSettings) if (settings[key] === undefined) settings[key] = $.ajaxSettings[key]\n\n    ajaxStart(settings)\n\n    if (!settings.crossDomain) {\n      urlAnchor = document.createElement('a')\n      urlAnchor.href = settings.url\n      urlAnchor.href = urlAnchor.href\n      settings.crossDomain = (originAnchor.protocol + '//' + originAnchor.host) !== (urlAnchor.protocol + '//' + urlAnchor.host)\n    }\n\n    if (!settings.url) settings.url = window.location.toString()\n    serializeData(settings)\n\n    var dataType = settings.dataType, hasPlaceholder = /\\?.+=\\?/.test(settings.url)\n    if (hasPlaceholder) dataType = 'jsonp'\n\n    if (settings.cache === false || (\n         (!options || options.cache !== true) &&\n         ('script' == dataType || 'jsonp' == dataType)\n        ))\n      settings.url = appendQuery(settings.url, '_=' + Date.now())\n\n    if ('jsonp' == dataType) {\n      if (!hasPlaceholder)\n        settings.url = appendQuery(settings.url,\n          settings.jsonp ? (settings.jsonp + '=?') : settings.jsonp === false ? '' : 'callback=?')\n      return $.ajaxJSONP(settings, deferred)\n    }\n\n    var mime = settings.accepts[dataType],\n        headers = { },\n        setHeader = function(name, value) { headers[name.toLowerCase()] = [name, value] },\n        protocol = /^([\\w-]+:)\\/\\//.test(settings.url) ? RegExp.$1 : window.location.protocol,\n        xhr = settings.xhr(),\n        nativeSetHeader = xhr.setRequestHeader,\n        abortTimeout\n\n    if (deferred) deferred.promise(xhr)\n\n    if (!settings.crossDomain) setHeader('X-Requested-With', 'XMLHttpRequest')\n    setHeader('Accept', mime || '*/*')\n    if (mime = settings.mimeType || mime) {\n      if (mime.indexOf(',') > -1) mime = mime.split(',', 2)[0]\n      xhr.overrideMimeType && xhr.overrideMimeType(mime)\n    }\n    if (settings.contentType || (settings.contentType !== false && settings.data && settings.type.toUpperCase() != 'GET'))\n      setHeader('Content-Type', settings.contentType || 'application/x-www-form-urlencoded')\n\n    if (settings.headers) for (name in settings.headers) setHeader(name, settings.headers[name])\n    xhr.setRequestHeader = setHeader\n\n    xhr.onreadystatechange = function(){\n      if (xhr.readyState == 4) {\n        xhr.onreadystatechange = empty\n        clearTimeout(abortTimeout)\n        var result, error = false\n        if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304 || (xhr.status == 0 && protocol == 'file:')) {\n          dataType = dataType || mimeToDataType(settings.mimeType || xhr.getResponseHeader('content-type'))\n          result = xhr.responseText\n\n          try {\n            // http://perfectionkills.com/global-eval-what-are-the-options/\n            if (dataType == 'script')    (1,eval)(result)\n            else if (dataType == 'xml')  result = xhr.responseXML\n            else if (dataType == 'json') result = blankRE.test(result) ? null : $.parseJSON(result)\n          } catch (e) { error = e }\n\n          if (error) ajaxError(error, 'parsererror', xhr, settings, deferred)\n          else ajaxSuccess(result, xhr, settings, deferred)\n        } else {\n          ajaxError(xhr.statusText || null, xhr.status ? 'error' : 'abort', xhr, settings, deferred)\n        }\n      }\n    }\n\n    if (ajaxBeforeSend(xhr, settings) === false) {\n      xhr.abort()\n      ajaxError(null, 'abort', xhr, settings, deferred)\n      return xhr\n    }\n\n    if (settings.xhrFields) for (name in settings.xhrFields) xhr[name] = settings.xhrFields[name]\n\n    var async = 'async' in settings ? settings.async : true\n    xhr.open(settings.type, settings.url, async, settings.username, settings.password)\n\n    for (name in headers) nativeSetHeader.apply(xhr, headers[name])\n\n    if (settings.timeout > 0) abortTimeout = setTimeout(function(){\n        xhr.onreadystatechange = empty\n        xhr.abort()\n        ajaxError(null, 'timeout', xhr, settings, deferred)\n      }, settings.timeout)\n\n    // avoid sending empty string (#319)\n    xhr.send(settings.data ? settings.data : null)\n    return xhr\n  }\n\n  // handle optional data/success arguments\n  function parseArguments(url, data, success, dataType) {\n    if ($.isFunction(data)) dataType = success, success = data, data = undefined\n    if (!$.isFunction(success)) dataType = success, success = undefined\n    return {\n      url: url\n    , data: data\n    , success: success\n    , dataType: dataType\n    }\n  }\n\n  $.get = function(/* url, data, success, dataType */){\n    return $.ajax(parseArguments.apply(null, arguments))\n  }\n\n  $.post = function(/* url, data, success, dataType */){\n    var options = parseArguments.apply(null, arguments)\n    options.type = 'POST'\n    return $.ajax(options)\n  }\n\n  $.getJSON = function(/* url, data, success */){\n    var options = parseArguments.apply(null, arguments)\n    options.dataType = 'json'\n    return $.ajax(options)\n  }\n\n  $.fn.load = function(url, data, success){\n    if (!this.length) return this\n    var self = this, parts = url.split(/\\s/), selector,\n        options = parseArguments(url, data, success),\n        callback = options.success\n    if (parts.length > 1) options.url = parts[0], selector = parts[1]\n    options.success = function(response){\n      self.html(selector ?\n        $('<div>').html(response.replace(rscript, \"\")).find(selector)\n        : response)\n      callback && callback.apply(self, arguments)\n    }\n    $.ajax(options)\n    return this\n  }\n\n  var escape = encodeURIComponent\n\n  function serialize(params, obj, traditional, scope){\n    var type, array = $.isArray(obj), hash = $.isPlainObject(obj)\n    $.each(obj, function(key, value) {\n      type = $.type(value)\n      if (scope) key = traditional ? scope :\n        scope + '[' + (hash || type == 'object' || type == 'array' ? key : '') + ']'\n      // handle data in serializeArray() format\n      if (!scope && array) params.add(value.name, value.value)\n      // recurse into nested objects\n      else if (type == \"array\" || (!traditional && type == \"object\"))\n        serialize(params, value, traditional, key)\n      else params.add(key, value)\n    })\n  }\n\n  $.param = function(obj, traditional){\n    var params = []\n    params.add = function(key, value) {\n      if ($.isFunction(value)) value = value()\n      if (value == null) value = \"\"\n      this.push(escape(key) + '=' + escape(value))\n    }\n    serialize(params, obj, traditional)\n    return params.join('&').replace(/%20/g, '+')\n  }\n})(Zepto)\n\n;(function($){\n  $.fn.serializeArray = function() {\n    var name, type, result = [],\n      add = function(value) {\n        if (value.forEach) return value.forEach(add)\n        result.push({ name: name, value: value })\n      }\n    if (this[0]) $.each(this[0].elements, function(_, field){\n      type = field.type, name = field.name\n      if (name && field.nodeName.toLowerCase() != 'fieldset' &&\n        !field.disabled && type != 'submit' && type != 'reset' && type != 'button' && type != 'file' &&\n        ((type != 'radio' && type != 'checkbox') || field.checked))\n          add($(field).val())\n    })\n    return result\n  }\n\n  $.fn.serialize = function(){\n    var result = []\n    this.serializeArray().forEach(function(elm){\n      result.push(encodeURIComponent(elm.name) + '=' + encodeURIComponent(elm.value))\n    })\n    return result.join('&')\n  }\n\n  $.fn.submit = function(callback) {\n    if (0 in arguments) this.bind('submit', callback)\n    else if (this.length) {\n      var event = $.Event('submit')\n      this.eq(0).trigger(event)\n      if (!event.isDefaultPrevented()) this.get(0).submit()\n    }\n    return this\n  }\n\n})(Zepto)\n\n;(function($, undefined){\n  var prefix = '', eventPrefix, endEventName, endAnimationName,\n    vendors = { Webkit: 'webkit', Moz: '', O: 'o' },\n    document = window.document, testEl = document.createElement('div'),\n    supportedTransforms = /^((translate|rotate|scale)(X|Y|Z|3d)?|matrix(3d)?|perspective|skew(X|Y)?)$/i,\n    transform,\n    transitionProperty, transitionDuration, transitionTiming, transitionDelay,\n    animationName, animationDuration, animationTiming, animationDelay,\n    cssReset = {}\n\n  function dasherize(str) { return str.replace(/([a-z])([A-Z])/, '$1-$2').toLowerCase() }\n  function normalizeEvent(name) { return eventPrefix ? eventPrefix + name : name.toLowerCase() }\n\n  $.each(vendors, function(vendor, event){\n    if (testEl.style[vendor + 'TransitionProperty'] !== undefined) {\n      prefix = '-' + vendor.toLowerCase() + '-'\n      eventPrefix = event\n      return false\n    }\n  })\n\n  transform = prefix + 'transform'\n  cssReset[transitionProperty = prefix + 'transition-property'] =\n  cssReset[transitionDuration = prefix + 'transition-duration'] =\n  cssReset[transitionDelay    = prefix + 'transition-delay'] =\n  cssReset[transitionTiming   = prefix + 'transition-timing-function'] =\n  cssReset[animationName      = prefix + 'animation-name'] =\n  cssReset[animationDuration  = prefix + 'animation-duration'] =\n  cssReset[animationDelay     = prefix + 'animation-delay'] =\n  cssReset[animationTiming    = prefix + 'animation-timing-function'] = ''\n\n  $.fx = {\n    off: (eventPrefix === undefined && testEl.style.transitionProperty === undefined),\n    speeds: { _default: 400, fast: 200, slow: 600 },\n    cssPrefix: prefix,\n    transitionEnd: normalizeEvent('TransitionEnd'),\n    animationEnd: normalizeEvent('AnimationEnd')\n  }\n\n  $.fn.animate = function(properties, duration, ease, callback, delay){\n    if ($.isFunction(duration))\n      callback = duration, ease = undefined, duration = undefined\n    if ($.isFunction(ease))\n      callback = ease, ease = undefined\n    if ($.isPlainObject(duration))\n      ease = duration.easing, callback = duration.complete, delay = duration.delay, duration = duration.duration\n    if (duration) duration = (typeof duration == 'number' ? duration :\n                    ($.fx.speeds[duration] || $.fx.speeds._default)) / 1000\n    if (delay) delay = parseFloat(delay) / 1000\n    return this.anim(properties, duration, ease, callback, delay)\n  }\n\n  $.fn.anim = function(properties, duration, ease, callback, delay){\n    var key, cssValues = {}, cssProperties, transforms = '',\n        that = this, wrappedCallback, endEvent = $.fx.transitionEnd,\n        fired = false\n\n    if (duration === undefined) duration = $.fx.speeds._default / 1000\n    if (delay === undefined) delay = 0\n    if ($.fx.off) duration = 0\n\n    if (typeof properties == 'string') {\n      // keyframe animation\n      cssValues[animationName] = properties\n      cssValues[animationDuration] = duration + 's'\n      cssValues[animationDelay] = delay + 's'\n      cssValues[animationTiming] = (ease || 'linear')\n      endEvent = $.fx.animationEnd\n    } else {\n      cssProperties = []\n      // CSS transitions\n      for (key in properties)\n        if (supportedTransforms.test(key)) transforms += key + '(' + properties[key] + ') '\n        else cssValues[key] = properties[key], cssProperties.push(dasherize(key))\n\n      if (transforms) cssValues[transform] = transforms, cssProperties.push(transform)\n      if (duration > 0 && typeof properties === 'object') {\n        cssValues[transitionProperty] = cssProperties.join(', ')\n        cssValues[transitionDuration] = duration + 's'\n        cssValues[transitionDelay] = delay + 's'\n        cssValues[transitionTiming] = (ease || 'linear')\n      }\n    }\n\n    wrappedCallback = function(event){\n      if (typeof event !== 'undefined') {\n        if (event.target !== event.currentTarget) return // makes sure the event didn't bubble from \"below\"\n        $(event.target).unbind(endEvent, wrappedCallback)\n      } else\n        $(this).unbind(endEvent, wrappedCallback) // triggered by setTimeout\n\n      fired = true\n      $(this).css(cssReset)\n      callback && callback.call(this)\n    }\n    if (duration > 0){\n      this.bind(endEvent, wrappedCallback)\n      // transitionEnd is not always firing on older Android phones\n      // so make sure it gets fired\n      setTimeout(function(){\n        if (fired) return\n        wrappedCallback.call(that)\n      }, ((duration + delay) * 1000) + 25)\n    }\n\n    // trigger page reflow so new elements can animate\n    this.size() && this.get(0).clientLeft\n\n    this.css(cssValues)\n\n    if (duration <= 0) setTimeout(function() {\n      that.each(function(){ wrappedCallback.call(this) })\n    }, 0)\n\n    return this\n  }\n\n  testEl = null\n})(Zepto)\n\n;(function($){\n  var zepto = $.zepto, oldQsa = zepto.qsa, oldMatches = zepto.matches\n\n  function visible(elem){\n    elem = $(elem)\n    return !!(elem.width() || elem.height()) && elem.css(\"display\") !== \"none\"\n  }\n\n  // Implements a subset from:\n  // http://api.jquery.com/category/selectors/jquery-selector-extensions/\n  //\n  // Each filter function receives the current index, all nodes in the\n  // considered set, and a value if there were parentheses. The value\n  // of `this` is the node currently being considered. The function returns the\n  // resulting node(s), null, or undefined.\n  //\n  // Complex selectors are not supported:\n  //   li:has(label:contains(\"foo\")) + li:has(label:contains(\"bar\"))\n  //   ul.inner:first > li\n  var filters = $.expr[':'] = {\n    visible:  function(){ if (visible(this)) return this },\n    hidden:   function(){ if (!visible(this)) return this },\n    selected: function(){ if (this.selected) return this },\n    checked:  function(){ if (this.checked) return this },\n    parent:   function(){ return this.parentNode },\n    first:    function(idx){ if (idx === 0) return this },\n    last:     function(idx, nodes){ if (idx === nodes.length - 1) return this },\n    eq:       function(idx, _, value){ if (idx === value) return this },\n    contains: function(idx, _, text){ if ($(this).text().indexOf(text) > -1) return this },\n    has:      function(idx, _, sel){ if (zepto.qsa(this, sel).length) return this }\n  }\n\n  var filterRe = new RegExp('(.*):(\\\\w+)(?:\\\\(([^)]+)\\\\))?$\\\\s*'),\n      childRe  = /^\\s*>/,\n      classTag = 'Zepto' + (+new Date())\n\n  function process(sel, fn) {\n    // quote the hash in `a[href^=#]` expression\n    sel = sel.replace(/=#\\]/g, '=\"#\"]')\n    var filter, arg, match = filterRe.exec(sel)\n    if (match && match[2] in filters) {\n      filter = filters[match[2]], arg = match[3]\n      sel = match[1]\n      if (arg) {\n        var num = Number(arg)\n        if (isNaN(num)) arg = arg.replace(/^[\"']|[\"']$/g, '')\n        else arg = num\n      }\n    }\n    return fn(sel, filter, arg)\n  }\n\n  zepto.qsa = function(node, selector) {\n    return process(selector, function(sel, filter, arg){\n      try {\n        var taggedParent\n        if (!sel && filter) sel = '*'\n        else if (childRe.test(sel))\n          // support \"> *\" child queries by tagging the parent node with a\n          // unique class and prepending that classname onto the selector\n          taggedParent = $(node).addClass(classTag), sel = '.'+classTag+' '+sel\n\n        var nodes = oldQsa(node, sel)\n      } catch(e) {\n        console.error('error performing selector: %o', selector)\n        throw e\n      } finally {\n        if (taggedParent) taggedParent.removeClass(classTag)\n      }\n      return !filter ? nodes :\n        zepto.uniq($.map(nodes, function(n, i){ return filter.call(n, i, nodes, arg) }))\n    })\n  }\n\n  zepto.matches = function(node, selector){\n    return process(selector, function(sel, filter, arg){\n      return (!sel || oldMatches(node, sel)) &&\n        (!filter || filter.call(node, null, arg) === node)\n    })\n  }\n})(Zepto)\n\n;(function($){\n  $.fn.end = function(){\n    return this.prevObject || $()\n  }\n\n  $.fn.andSelf = function(){\n    return this.add(this.prevObject || $())\n  }\n\n  'filter,add,not,eq,first,last,find,closest,parents,parent,children,siblings'.split(',').forEach(function(property){\n    var fn = $.fn[property]\n    $.fn[property] = function(){\n      var ret = fn.apply(this, arguments)\n      ret.prevObject = this\n      return ret\n    }\n  })\n})(Zepto)\n\n;(function($){\n  var data = {}, dataAttr = $.fn.data, camelize = $.camelCase,\n    exp = $.expando = 'Zepto' + (+new Date()), emptyArray = []\n\n  // Get value from node:\n  // 1. first try key as given,\n  // 2. then try camelized key,\n  // 3. fall back to reading \"data-*\" attribute.\n  function getData(node, name) {\n    var id = node[exp], store = id && data[id]\n    if (name === undefined) return store || setData(node)\n    else {\n      if (store) {\n        if (name in store) return store[name]\n        var camelName = camelize(name)\n        if (camelName in store) return store[camelName]\n      }\n      return dataAttr.call($(node), name)\n    }\n  }\n\n  // Store value under camelized key on node\n  function setData(node, name, value) {\n    var id = node[exp] || (node[exp] = ++$.uuid),\n      store = data[id] || (data[id] = attributeData(node))\n    if (name !== undefined) store[camelize(name)] = value\n    return store\n  }\n\n  // Read all \"data-*\" attributes from a node\n  function attributeData(node) {\n    var store = {}\n    $.each(node.attributes || emptyArray, function(i, attr){\n      if (attr.name.indexOf('data-') == 0)\n        store[camelize(attr.name.replace('data-', ''))] =\n          $.zepto.deserializeValue(attr.value)\n    })\n    return store\n  }\n\n  $.fn.data = function(name, value) {\n    return value === undefined ?\n      // set multiple values via object\n      $.isPlainObject(name) ?\n        this.each(function(i, node){\n          $.each(name, function(key, value){ setData(node, key, value) })\n        }) :\n        // get value from first element\n        (0 in this ? getData(this[0], name) : undefined) :\n      // set value on all elements\n      this.each(function(){ setData(this, name, value) })\n  }\n\n  $.fn.removeData = function(names) {\n    if (typeof names == 'string') names = names.split(/\\s+/)\n    return this.each(function(){\n      var id = this[exp], store = id && data[id]\n      if (store) $.each(names || store, function(key){\n        delete store[names ? camelize(this) : key]\n      })\n    })\n  }\n\n  // Generate extended `remove` and `empty` functions\n  ;['remove', 'empty'].forEach(function(methodName){\n    var origFn = $.fn[methodName]\n    $.fn[methodName] = function() {\n      var elements = this.find('*')\n      if (methodName === 'remove') elements = elements.add(this)\n      elements.removeData()\n      return origFn.call(this)\n    }\n  })\n})(Zepto)\n;\ndefine(\"baseSelectorLibrary\", (function (global) {\n    return function () {\n        var ret, fn;\n        return ret || global.$;\n    };\n}(this)));\n\n",
    "/**\n * A selector library which is extended from a base selector library,\n * but with a constructer that calls the selector engine on the doc\n * defined in the closure, and a few additional methods for\n * getting/setting that document.\n */\ndefine('$',['baseSelectorLibrary'], function($) {\n    var doc = document;\n\n    var SelectorLibrary = function(selector, context, rootQuery) {\n        if ($.fn.init) {\n            return new $.fn.init(selector, context || doc, rootQuery);\n        }\n        return $.zepto.init.call(this, selector, context || doc, rootQuery);\n    };\n\n    /**\n     *  Binds the passed document to the selector engine.\n     *  All queries are done against that document, not the current document.\n     */\n    SelectorLibrary.attachDocument = function(document) {\n        doc = document;\n    };\n\n    SelectorLibrary.getDocument = function() {\n        return doc;\n    };\n\n    $.extend(SelectorLibrary, $);\n\n    return SelectorLibrary;\n});\n\n",
    "(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define('mobifyjs/utils',[], factory);\n    } else if (typeof exports === 'object') {\n        // Node. Does not work with strict CommonJS, but\n        // only CommonJS-like environments that support module.exports,\n        // like Node.\n        module.exports = factory();\n    } else {\n        // Browser globals (root is window)\n        root.Utils = factory();\n    }\n}(this, function () {\n\n// ##\n// # Utility methods\n// ##\n\nvar Utils = {};\n\nUtils.extend = function(target){\n    [].slice.call(arguments, 1).forEach(function(source) {\n        for (var key in source)\n            if (source[key] !== undefined)\n                target[key] = source[key];\n    });\n    return target;\n};\n\nUtils.keys = function(obj) {\n    var result = [];\n    for (var key in obj) {\n        if (obj.hasOwnProperty(key))\n            result.push(key);\n    }\n    return result;\n};\n\nUtils.values = function(obj) {\n    var result = [];\n    for (var key in obj) {\n      if (obj.hasOwnProperty(key))\n          result.push(obj[key]);\n    }\n    return result;\n};\n\nUtils.clone = function(obj) {\n    var target = {};\n    for (var i in obj) {\n        if (obj.hasOwnProperty(i)) {\n          target[i] = obj[i];\n        }\n    }\n    return target;\n};\n\n// Some url helpers\n/**\n * Takes a url, relative or absolute, and absolutizes it relative to the current \n * document's location/base, with the assistance of an a element.\n */\nvar _absolutifyAnchor = document.createElement(\"a\");\nUtils.absolutify = function(url) {\n    _absolutifyAnchor.href = url;\n    return _absolutifyAnchor.href;\n};\n\n/**\n * Takes an absolute url, returns true if it is an http/s url, false otherwise \n * (e.g. mailto:, gopher://, data:, etc.)\n */\nvar _httpUrlRE = /^https?/;\nUtils.httpUrl = function(url) {\n    return _httpUrlRE.test(url);\n};\n\n/**\n * outerHTML polyfill - https://gist.github.com/889005\n */\nUtils.outerHTML = function(el){\n    if (el.outerHTML) {\n        return el.outerHTML;\n    }\n    else {\n        var div = document.createElement('div');\n        div.appendChild(el.cloneNode(true));\n        var contents = div.innerHTML;\n        div = null;\n        return contents;\n    }\n};\n\n/**\n * Return a string for the doctype of the current document.\n */\nUtils.getDoctype = function(doc) {\n    doc = doc || document;\n    var doctypeEl = doc.doctype || [].filter.call(doc.childNodes, function(el) {\n            return el.nodeType == Node.DOCUMENT_TYPE_NODE\n        })[0];\n\n    if (!doctypeEl) return '';\n\n    return '<!DOCTYPE HTML'\n        + (doctypeEl.publicId ? ' PUBLIC \"' + doctypeEl.publicId + '\"' : '')\n        + (doctypeEl.systemId ? ' \"' + doctypeEl.systemId + '\"' : '')\n        + '>';\n};\n\n/**\n * Returns an object that represents the parsed content attribute of the\n * viewport meta tag. Returns false if no viewport meta tag is present.\n */\nUtils.getMetaViewportProperties = function(doc) {\n    // Regex to split comma-delimited viewport meta tag properties\n    var SPLIT_PROPERTIES_REGEX = /,\\s?/;\n\n    doc = doc || document;\n    var parsedProperties = {}\n\n    // Get the viewport meta tag\n    var viewport = doc.querySelectorAll('meta[name=\"viewport\"]');\n    if (viewport.length == 0) {\n        return false;\n    }\n\n    // Split its properties\n    var content = viewport[0].getAttribute('content');\n    if (content == null) {\n        return false;\n    }\n    var properties = content.split(SPLIT_PROPERTIES_REGEX);\n\n    // Parse the properties into an object\n    for (var i = 0; i < properties.length; i++) {\n        var property = properties[i].split('=')\n\n        if (property.length >= 2) {\n            var key = property[0];\n            var value = property[1];\n            parsedProperties[key] = value;\n        }\n    }\n\n    return parsedProperties;\n}\n\nUtils.removeBySelector = function(selector, doc) {\n    doc = doc || document;\n\n    var els = doc.querySelectorAll(selector);\n    return Utils.removeElements(els, doc);\n};\n\nUtils.removeElements = function(elements, doc) {\n    doc = doc || document;\n\n    for (var i=0,ii=elements.length; i<ii; i++) {\n        var el = elements[i];\n        el.parentNode.removeChild(el);\n    }\n    return elements;\n};\n\n// localStorage detection as seen in such great libraries as Modernizr\n// https://github.com/Modernizr/Modernizr/blob/master/feature-detects/storage/localstorage.js\n// Exposing on Jazzcat for use in qunit tests\nvar cachedLocalStorageSupport;\nUtils.supportsLocalStorage = function() {\n    if (cachedLocalStorageSupport !== undefined) {\n        return cachedLocalStorageSupport;\n    }\n    var mod = 'modernizr';\n    try {\n        localStorage.setItem(mod, mod);\n        localStorage.removeItem(mod);\n        cachedLocalStorageSupport = true;\n    } catch(e) {\n        cachedLocalStorageSupport = false\n    }\n    return cachedLocalStorageSupport;\n};\n\n// matchMedia polyfill generator\n// (allows you to specify which document to run polyfill on)\nUtils.matchMedia = function(doc) {\n    \"use strict\";\n\n    var bool,\n        docElem = doc.documentElement,\n        refNode = docElem.firstElementChild || docElem.firstChild,\n        // fakeBody required for <FF4 when executed in <head>\n        fakeBody = doc.createElement(\"body\"),\n        div = doc.createElement(\"div\");\n\n    div.id = \"mq-test-1\";\n    div.style.cssText = \"position:absolute;top:-100em\";\n    fakeBody.style.background = \"none\";\n    fakeBody.appendChild(div);\n\n    return function(q){\n        div.innerHTML = \"&shy;<style media=\\\"\" + q + \"\\\"> #mq-test-1 { width: 42px; }</style>\";\n\n        docElem.insertBefore(fakeBody, refNode);\n        bool = div.offsetWidth === 42;\n        docElem.removeChild(fakeBody);\n\n        return {\n           matches: bool,\n           media: q\n        };\n    };\n};\n\n// readyState: loading --> interactive --> complete\n//                      |               |\n//                      |               |\n//                      v               v\n// Event:        DOMContentLoaded    onload\n//\n// iOS 4.3 and some Android 2.X.X have a non-typical \"loaded\" readyState,\n// which is an acceptable readyState to start capturing on, because\n// the data is fully loaded from the server at that state.\n// For some IE (IE10 on Lumia 920 for example), interactive is not \n// indicative of the DOM being ready, therefore \"complete\" is the only acceptable\n// readyState for IE10\n// Credit to https://github.com/jquery/jquery/commit/0f553ed0ca0c50c5f66377e9f2c6314f822e8f25\n// for the IE10 fix\nUtils.domIsReady = function(doc) {\n    var doc = doc || document;\n    return doc.attachEvent ? doc.readyState === \"complete\" : doc.readyState !== \"loading\";\n};\n\nUtils.getPhysicalScreenSize = function(devicePixelRatio) {\n\n    function multiplyByPixelRatio(sizes) {\n        var dpr = devicePixelRatio || window.devicePixelRatio || 1;\n\n        sizes.width = Math.round(sizes.width * dpr);\n        sizes.height = Math.round(sizes.height * dpr);\n\n        return sizes;\n    }\n\n    var iOS = navigator.userAgent.match(/ip(hone|od|ad)/i);\n    var androidVersion = (navigator.userAgent.match(/android (\\d)/i) || {})[1];\n\n    var sizes = {\n        width: window.outerWidth\n      , height: window.outerHeight\n    };\n\n    // Old Android and BB10 use physical pixels in outerWidth/Height, which is what we need\n    // New Android (4.0 and above) use CSS pixels, requiring devicePixelRatio multiplication\n    // iOS lies about outerWidth/Height when zooming, but does expose CSS pixels in screen.width/height\n\n    if (!iOS) {\n        if (androidVersion > 3) return multiplyByPixelRatio(sizes);\n        return sizes;\n    }\n\n    var isLandscape = window.orientation % 180;\n    if (isLandscape) {\n        sizes.height = screen.width;\n        sizes.width = screen.height;\n    } else {\n        sizes.width = screen.width;\n        sizes.height = screen.height;\n    }\n\n    return multiplyByPixelRatio(sizes);\n};\n\nUtils.waitForReady = function(doc, callback) {\n    // Waits for `doc` to be ready, and then fires callback, passing\n    // `doc`.\n\n    // We may be in \"loading\" state by the time we get here, meaning we are\n    // not ready to capture. Next step after \"loading\" is \"interactive\",\n    // which is a valid state to start capturing on (except IE), and thus when ready\n    // state changes once, we know we are good to start capturing.\n    // Cannot rely on using DOMContentLoaded because this event prematurely fires\n    // for some IE10s.\n    var ready = false;\n    \n    var onReady = function() {\n        if (!ready) {\n            ready = true;\n            iid && clearInterval(iid);\n            callback(doc);\n        }\n    }\n\n    // Backup with polling incase readystatechange doesn't fire\n    // (happens with some Android 2.3 browsers)\n    var iid = setInterval(function(){\n        if (Utils.domIsReady(doc)) {\n            onReady();\n        }\n    }, 100);\n\n    doc.addEventListener(\"readystatechange\", onReady, false);\n};\n\nreturn Utils;\n\n}));\n\n",
    "define('buildConfig',[], function() {\n    return {\n        buildDate: 1428602192541,\n        cacheHashManifest: {\"css/stylesheet.css\":\"dc254043\",\"css/stylesheet.css.map\":\"912b61a3\",\"js/ui.js\":\"cc625f4e\",\"js/ui.js.map\":\"85ea2e1a\",\"bower_components/deckard/dist/deckard.min.js\":\"8b1854e7\"}\n    }\n});\n",
    "define('adaptivejs/utils',[\n    'mobifyjs/utils',\n    'buildConfig',\n], function(Utils, buildConfig) {\n\n    var AdaptiveUtils = {};\n    Utils.extend(AdaptiveUtils, Utils);\n\n    /**\n     *  Pulled from Lodash, because we only use these few functions.\n     */\n    AdaptiveUtils.isFunction = function(value) {\n        return typeof value === 'function';\n    };\n\n    // fallback for older versions of Chrome and Safari\n    if (AdaptiveUtils.isFunction(/x/)) {\n        AdaptiveUtils.isFunction = function(value) {\n            return typeof value === 'function' && Object.prototype.toString.call(value) === '[object Function]';\n        };\n    }\n\n    AdaptiveUtils.isObject = function(value) {\n        // check if the value is the ECMAScript language type of Object\n        // http://es5.github.io/#x8\n        // and avoid a V8 bug\n        // https://code.google.com/p/v8/issues/detail?id=2291\n        var type = typeof value;\n        return value && (type === 'function' || type === 'object') || false;\n    };\n\n    AdaptiveUtils.isRegExp = function(value) {\n        var type = typeof value;\n\n        return value && (type === 'function' || type === 'object') &&\n            Object.prototype.toString.call(value) === '[object RegExp]' || false;\n    };\n\n    /**\n     *  Creates a script string that will load a.js\n     */\n    AdaptiveUtils.getAjs = function(name, template) {\n        var qs = template ? 'm=1&t=' + template : 't=miss';\n\n        return '<script src=\"//a.mobify.com/' + name + '/a.js#' + qs + '\" async></script>';\n    };\n\n    /**\n     * Determines if the supplied node is a Node type, or a Node type of\n     * the node's window. On some browsers Nodes created within an iframe\n     * are not instances of the root/parent document's Node class.\n     */\n    var isNode = function(node) {\n        return (node instanceof Node) ||\n               (node && node.ownerDocument && node.ownerDocument.defaultView &&\n                (node instanceof node.ownerDocument.defaultView.Node));\n    };\n\n    /**\n     *  Returns true if obj is a Zepto/jQuery object or a DOM node\n     */\n    AdaptiveUtils.isDOMLike = function(obj) {\n        if (window.Zepto && Zepto.zepto.isZ(obj)) {\n            return true;\n        } else if (window.jQuery && obj instanceof jQuery.fn.constructor) {\n            return true;\n        } else if (isNode(obj)) {\n            return true;\n        }\n\n        return obj instanceof HTMLElement;\n    };\n\n    /**\n     *  Returns the url of the adaptive.js build file and caches it\n     */\n    var cachedBuildScript;\n    AdaptiveUtils.getAdaptiveBuildScript = function() {\n        try {\n            // Get the first script on the page\n            // If it's the build script, cache it and return it\n            if (cachedBuildScript) {\n                return cachedBuildScript;\n            }\n            var firstScript = document.getElementsByTagName('script')[0];\n            if (/(mobify|adaptive)(\\.min)?\\.js/.test(firstScript.getAttribute('src'))) {\n                cachedBuildScript = cachedBuildScript || firstScript;\n                return cachedBuildScript;\n            }\n            return undefined;\n        } catch (e) {\n            console.error('Couldn\\'t determine adaptivejs build file used. The mobify-tag may be placed incorrectly.');\n        }\n    };\n\n    /**\n     *  Grabs the location of the build so we can reference assets\n     *  with absolute urls\n     */\n    AdaptiveUtils.getBuildOrigin = function() {\n        var buildOrigin = '//localhost:8080/';\n        var adaptiveBuildScript = this.getAdaptiveBuildScript();\n\n        if (adaptiveBuildScript) {\n            try {\n                var adaptiveBuildSrc = adaptiveBuildScript.getAttribute('src');\n                buildOrigin = adaptiveBuildSrc.replace(/\\/[^\\/]*$/, '/');\n            } catch (e) {\n                console.error('Couldn\\'t determine adaptivejs build file used. The mobify-tag may be placed incorrectly.');\n            }\n        }\n        return buildOrigin;\n    };\n\n    /**\n     *  Returns the full url for the provided asset path\n     *  including a cache breaker.\n     *  basePath and cacheBreaker arguments are optional\n     */\n    AdaptiveUtils.getAssetUrl = function(path, baseUrl, cacheBreaker) {\n        var hash = buildConfig.cacheHashManifest[path];\n\n        // If path isn't found in the hashManifest, cache break with build date\n        if (cacheBreaker === undefined) {\n            cacheBreaker = hash ? hash : buildConfig.buildDate;\n        }\n\n        return (baseUrl || this.getBuildOrigin()) + path + '?' + cacheBreaker;\n    };\n\n    /**\n     *  If the mobify-path cookie is present, then we are in debug mode\n     */\n    AdaptiveUtils.isDebug = function(cookie) {\n        cookie = cookie || document.cookie;\n\n        var match = /mobify-path=([^&;]*)/.exec(cookie);\n\n        return !!match;\n    };\n\n    return AdaptiveUtils;\n\n});\n\n",
    "define('adaptivejs/logger',[\n    'adaptivejs/utils'\n], function(Utils) {\n\n    var Logger = {};\n    var TIMING_POINTS = Logger.TIMING_POINTS = 'adaptiveTimingPoints';\n\n    /**\n     *  Lets guard our calls to set item for two possible failure\n     *  scenarios\n     *    1) The device does not supportLocalStorage\n     *    2) Local storage is full\n     */\n    var setItem = function(item, value) {\n        if (!Utils.supportsLocalStorage()) {\n            return;\n        }\n        try {\n            return localStorage.setItem(item, value);\n        } catch (e) {\n            return;\n        }\n    };\n\n    /**\n     *  Setup the logger and initialize the start time\n     *  Takes a debug argument and a start time,\n     *  both of which are optional.\n     */\n    Logger.init = function(options) {\n        options = options || {};\n        this.points = {};\n        var debug = options.debug !== undefined ? options.debug : false;\n        var start = options.start || +new Date();\n\n        // Make sure we aren't using any old logging points\n        this.clearData();\n\n        // Persist the debugger\n        this.setDebugger(debug);\n\n        // Tracks depth of recursion for output indentation\n        Logger.stackDepth = 1;\n\n        // Add the first timing point\n        this.addTimingPoint('Start', {value: start});\n    };\n\n    /**\n     *  Formats a name and data point into a nice logger entry\n     */\n    Logger.formatDataPoint = function(name, point) {\n        var points = this.points || this.getJSONFromLocalStorage(TIMING_POINTS);\n        var start = points.Start || 0;\n        var diff = point - start;\n        return name + ': ' + diff + 'ms';\n    };\n\n    /**\n     *  Increase value of stack depth tracker\n     */\n    Logger.increaseStack = function() {\n        this.stackDepth += 1;\n    };\n\n    /**\n     *  Decrease value of stack depth tracker\n     */\n    Logger.decreaseStack = function() {\n        this.stackDepth -= 1;\n    };\n\n    /**\n     *  Remove logging data from local storage\n     */\n    Logger.clearData = function() {\n        localStorage.removeItem(TIMING_POINTS);\n    };\n\n    /**\n     *  Resets the debugger if you need to do it at a later state\n     */\n    Logger.setDebugger = function(debug) {\n        this.debugMode = debug;\n        setItem('debug', debug);\n    };\n\n    /**\n     *  Uses the console to log the give message if debugMode is true\n     *  Takes an optional logLevel argument to log errors or warnings\n     */\n    Logger.log = function(message, logLevel) {\n        if (!this.debugMode) {\n            return;\n        }\n\n        logLevel = logLevel || 'log';\n        try {\n            console[logLevel](message);\n        } catch (e) {\n            console.log(message);\n        }\n    };\n\n    /**\n     *  Adds a data point to timing point group.\n     *\n     *  `key` is required.\n     *  `options.value` is optional\n     *   (if not given, the current timestamp will be added)\n     *  `options.namespace` is optional\n     *   (if not given, will log key to top level points object)\n     */\n    Logger.addTimingPoint = function(key, options) {\n        if (!this.debugMode) {\n            return;\n        }\n\n        options = options || {};\n\n        // Indent key based on it's stack depth\n        // SJ TODO: There is an issue where stackDepth can be undefined when\n        // using the Logger post-document.write. This needs to be addressed!\n        key = new Array(this.stackDepth || 1).join('\\t') + key;\n\n        // In non-Webkit based browsers, the `points` object will get blown away due\n        // to our use of `document.open`, thus if `points` is undefined, we will get\n        // the logging information from localStorage.\n        var points = this.points || this.getJSONFromLocalStorage(TIMING_POINTS) || {};\n        var value = options.value || +new Date();\n        var namespace = options.namespace;\n\n        if (namespace) {\n            points[namespace] = points[namespace] || {};\n            points[namespace][key] = value;\n        } else {\n            points[key] = value;\n        }\n        this.saveJSONToLocalStorage(TIMING_POINTS, points);\n    };\n\n    /**\n     * Deprecated function. Kept around for backwards compatibility.\n     */\n    Logger.addPoint = function(localStorageKey, key, options) {\n        Logger.addTimingPoint(key, options);\n    };\n\n    /**\n     *  Stringifies a JSON object then saves it to local storage\n     */\n    Logger.saveJSONToLocalStorage = function(name, collection) {\n        setItem(name, JSON.stringify(collection));\n    };\n\n    /**\n     *  Retrieves a JSON string from local storage and parses it into an object\n     */\n    Logger.getJSONFromLocalStorage = function(name) {\n        if (!Utils.supportsLocalStorage()) {\n            return;\n        }\n        try {\n            var jsonData = localStorage.getItem(name);\n            if (jsonData === null) {\n                return null;\n            }\n            return JSON.parse(jsonData);\n        } catch (e) {\n            console.error('Error getting data from local storage:\\n' + e);\n            return;\n        }\n    };\n\n    /**\n     *  Formats a logGroup if supported\n     */\n    Logger.logGroup = function(group, name) {\n        if (!this.debugMode) {\n            return;\n        }\n        console.groupCollapsed ? console.groupCollapsed(name) : console.group(name);\n\n        for (var key in group) {\n            if (group.hasOwnProperty(key)) {\n                // If the value is a string, parse it to JSON\n                if (Object.prototype.toString.call(group[key]) === '[object Object]') {\n                    this.logGroup(group[key], key);\n                }\n                else {\n                    console.log(Logger.formatDataPoint(key, group[key]));\n                }\n            }\n        }\n        console.groupEnd();\n    };\n\n    /**\n     *  Logs the content in a collapsed group\n     */\n    Logger.logCollapsed = function(groupName, content) {\n        if (!this.debugMode) {\n            return;\n        }\n        console.groupCollapsed ? console.groupCollapsed(groupName) : console.group(groupName);\n\n        console.log(content);\n        console.groupEnd();\n    };\n\n    /**\n     *  Adds the DOMContentLoaded event to the data points object\n     *  Name is optional\n     */\n    Logger.addDOMContentListener = function() {\n        var self = this;\n        document.addEventListener('DOMContentLoaded', function() {\n            self.addTimingPoint('DOMContentLoaded');\n        }, false);\n    };\n\n    /**\n     *  Adds both document and window listeners as some browsers prefer one over\n     *  the other. This is the same way jQuery handles this. Adds the point on\n     *  which is fired first.\n     */\n    Logger.addOnLoadListener = function(callback) {\n        var self = this;\n\n        var addPageLoadPointCallback = function() {\n            if (!this.pageLoaded) {\n                this.pageLoaded = +new Date();\n                self.addTimingPoint('Page Load', +new Date());\n                callback && callback();\n            }\n        };\n\n        document.addEventListener('load', addPageLoadPointCallback, false);\n        window.addEventListener('load', addPageLoadPointCallback, false);\n    };\n\n    Logger.logTimingPoints = function() {\n        var points = this.points || this.getJSONFromLocalStorage(TIMING_POINTS);\n        this.logGroup(points, 'Timing Points');\n    };\n\n    return Logger;\n});\n\n",
    "define('adaptivejs/router',[\n    'adaptivejs/logger',\n    'adaptivejs/utils'\n], function(Logger, Utils) {\n\n    var Router = function() {\n        this.routes = [];\n    };\n\n    /**\n     * Ignore constant, which allows users to give semantic meaning to\n     * opt out of a route.\n     *\n     * Example:\n     *\n     * router.add(function() {\n     *      return window.location.href === 'http://yourdomain.com/dont-match-this'; // true if route should not be matched\n     * }, Router.Ignore);\n     * @type {boolean}\n     */\n    Router.Ignore = false;\n\n    /**\n     *  Creates a route from a function and view pair. Stores\n     *  the result to be processed later on.\n     *  Returns this to allow for chaining of calls to `router.add`\n     */\n    Router.prototype.add = function(func, view) {\n        if (!Utils.isFunction(func)) {\n            console.error('AdaptiveJS Router - Error - First argument to add must be a function');\n        }\n\n        if (Utils.isObject(view) && !view.hasOwnProperty('template')) {\n            console.error('AdaptiveJS Router - Error - Second argument to add must be a View');\n        }\n\n        this.routes.push({func: func, view: view});\n\n        return this;\n    };\n\n    // adds: function(routes) {\n    //     // Map routes supplied and pass them in to add\n    //     // TODO: Implement\n    // },\n\n    /**\n     *  Evaluate a given route but make sure we don't bomb\n     *  out if we hit an error.\n     */\n    Router.prototype.evalRoute = function(route) {\n        var result;\n\n        try {\n            result = route.func(this.doc);\n        } catch (e) {\n            console.warn('Router error:', e.stack);\n        }\n\n        return result;\n    };\n\n    /**\n     *  Grab all of the routes currently contained in the router\n     */\n    Router.prototype.getRoutes = function() {\n        return this.routes;\n    };\n\n    /**\n     *  Given a document, lets run through our routes and see\n     *  which one matches.\n     *  Returns the view of the matched route.\n     */\n    Router.prototype.resolve = function(document) {\n        var result;\n        var self = this;\n\n        this.doc = document;\n\n        for (var i = 0, l = this.routes.length; i < l; i++) {\n            var route = this.routes[i];\n            if (self.evalRoute(route)){\n                result = route;\n                break;\n            }\n        }\n\n        Logger.addTimingPoint('Routes resolved');\n\n        return result ? result.view : result;\n    };\n\n    /**\n     *  Creates a function which checks to see if the given selector\n     *  is found within the document\n     */\n    Router.selectorMatch = function(selector) {\n        var self = this;\n        return function(capturedDoc) {\n            var result = capturedDoc.querySelectorAll(selector);\n\n            return result.length ? result : false;\n        };\n    };\n\n    /**\n     * Actually just the identity function.\n     * This is deprecated, mostly because it doesn't do anything :)\n     */\n    Router.jsMatch = function(func) {\n        console.warn('The Router.jsMatch function is deprecated. Please use an anonymous function instead.');\n        return func;\n    };\n\n    /**\n     *  URLMatching functionality\n     *  http://www.mobify.com/mobifyjs/docs/matching-to-urls/\n     */\n    Router.urlMatch = function(url) {\n        if (!Utils.isRegExp(url)) {\n            url = new RegExp(url);\n        }\n\n        return function() {\n            return url.test(document.URL);\n        };\n    };\n\n    return Router;\n});\n\n",
    "(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define('resizeImages',['mobifyjs/utils'], factory);\n    } else if (typeof exports === 'object') {\n        // Node. Does not work with strict CommonJS, but\n        // only CommonJS-like environments that support module.exports,\n        // like Node.\n        module.exports = factory(require('../mobifyjs-utils/utils.js'));\n    } else {\n        // Browser globals (root is window)\n        root.ResizeImages = factory(root.Utils);\n    }\n}(this, function (Utils) {\n\nvar ResizeImages = window.ResizeImages = {};\n\nvar localStorageWebpKey = 'Mobify-Webp-Support-v2';\n\nfunction persistWebpSupport(supported) {\n    if (Utils.supportsLocalStorage()) {\n        var webpSupport = {\n            supported: supported,\n            date: Date.now()\n        };\n        localStorage.setItem(localStorageWebpKey, JSON.stringify(webpSupport));\n    }\n}\n\n/**\n * Synchronous WEBP detection using regular expressions\n * Credit to Ilya Grigorik for WEBP regex matching\n * https://github.com/igrigorik/webp-detect/blob/master/pagespeed.cc\n * Modified to exclude Android native browser on Android 4\n */\nResizeImages.userAgentWebpDetect = function(userAgent){\n    var supportedRe = /(Android\\s|Chrome\\/|Opera9.8*Version\\/..\\.|Opera..\\.)/i;\n    var unsupportedVersionsRe = new RegExp('(Android\\\\s(0|1|2|3|(4(?!.*Chrome)))\\\\.)|(Chrome\\\\/[0-8]\\\\.)' +\n                                '|(Chrome\\\\/9\\\\.0\\\\.)|(Chrome\\\\/1[4-6]\\\\.)|(Android\\\\sChrome\\\\/1.\\\\.)' +\n                                '|(Android\\\\sChrome\\\\/20\\\\.)|(Chrome\\\\/(1.|20|21|22)\\\\.)' +\n                                '|(Opera.*(Version/|Opera\\\\s)(10|11)\\\\.)', 'i');\n\n    // Return false if browser is not supported\n    if (!supportedRe.test(userAgent)) {\n        return false;\n    }\n\n    // Return false if a specific browser version is not supported\n    if (unsupportedVersionsRe.test(userAgent)) {\n        return false;\n    }\n    return true;\n};\n\n/**\n * Asychronous WEB detection using a data uri.\n * Credit to Modernizer:\n * https://github.com/Modernizr/Modernizr/blob/fb76d75fbf97f715e666b55b8aa04e43ef809f5e/feature-detects/img-webp.js\n */\nResizeImages.dataUriWebpDetect = function(callback) {\n    var image = new Image();\n    image.onload = function() {\n        var support = (image.width === 1) ? true : false;\n        persistWebpSupport(support);\n        if (callback) callback(support);\n        };\n    // this webp generated with Mobify image resizer from \n    // http://upload.wikimedia.org/wikipedia/commons/c/ca/1x1.png passed \n    // through the Mobify Image resizer: \n    // http://ir0.mobify.com/webp/http://upload.wikimedia.org/wikipedia/commons/c/ca/1x1.png\n    image.src = 'data:image/webp;base64,UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAABBxAR/Q9ERP8DAABWUDggGAAAADABAJ0BKgEAAQABgBwlpAADcAD+/gbQAA==';\n};\n\n/**\n * Detect WEBP support sync and async. Do our best to determine support\n * with regex, and use data-uri method for future proofing.\n * (note: async test will not complete before first run of `resize`,\n * since onload of detector image won't fire until document is complete)\n * Also caches results for WEBP support in localStorage.\n */\nResizeImages.supportsWebp = function(callback) {\n\n    // Return early if we have persisted WEBP support\n    if (Utils.supportsLocalStorage()) {\n        \n        // Check if WEBP support has already been detected\n        var webpSupport;\n        var storedSupport = localStorage.getItem(localStorageWebpKey);\n\n        // Only JSON.parse if storedSupport is not null, or else things\n        // will break on Android 2.3\n        storedSupport && (webpSupport = JSON.parse(storedSupport));\n        \n        // Grab previously cached support value in localStorage.\n        if (webpSupport && (Date.now() - webpSupport.date < 604800000)) {\n            return webpSupport.supported;\n        }\n    }\n\n    // Run async WEBP detection for future proofing\n    // This test may not finish running before the first call of `resize`\n    ResizeImages.dataUriWebpDetect(callback);\n\n    // Run regex based synchronous WEBP detection\n    var support = ResizeImages.userAgentWebpDetect(navigator.userAgent);\n\n    persistWebpSupport(support);\n\n    return support;\n\n};\n\n/**\n * Returns a URL suitable for use with the 'ir' service.\n */\nResizeImages.getImageURL = function(url, options) {\n    var opts = options;\n    if (!opts) {\n        opts = ResizeImages.processOptions();\n    }\n    var bits = [opts.proto + opts.host];\n\n    if (opts.projectName) {\n        var projectId = \"project-\" + opts.projectName;\n        bits.push(projectId);\n    }\n\n    if (opts.cacheBreaker) {\n        bits.push('cb' + opts.cacheBreaker);\n    }\n\n    if (opts.cacheHours) {\n        bits.push('c' + opts.cacheHours);\n    }\n\n    if (opts.format) {\n        bits.push(opts.format + (opts.quality || ''));\n    } else if (opts.quality) {\n        bits.push('q' + opts.quality);\n    }\n\n    if (opts.maxWidth) {\n        bits.push(opts.maxWidth);\n\n        if (opts.maxHeight) {\n            bits.push(opts.maxHeight);\n        }\n    }\n\n    bits.push(url);\n    return bits.join('/');\n};\n\n/**\n * Replaces src attr of passed element with value of running `getImageUrl` on it\n * Allows overriding of img.getAttribute(x-src) with srcVal\n */\n\nResizeImages._rewriteSrcAttribute = function(element, opts, srcVal){\n    srcVal = element.getAttribute(opts.sourceAttribute) || srcVal;\n    if (srcVal) {\n        var url = Utils.absolutify(srcVal);\n        if (Utils.httpUrl(url)) {\n            if (opts.onerror) {\n                element.setAttribute('onerror', opts.onerror);\n            }\n            element.setAttribute(opts.targetAttribute, ResizeImages.getImageURL(url, opts));\n            element.setAttribute('data-orig-src', srcVal);\n            // if using resize when not capturing, remove the sourceAttribute\n            // as long as it's not \"src\", which is the target attribute used\n            // when not capturing.\n            if (!capturing && opts.sourceAttribute != opts.targetAttribute) {\n                element.removeAttribute(opts.sourceAttribute);\n            }\n        }\n    }\n};\n\n/**\n * Modifies src of `<source />` children of a `<picture>` element to use image \n * resizer\n */\nResizeImages._resizeSourceElement = function(element, opts, rootSrc) {\n    // Grab optional width override\n    var width = element.getAttribute('data-width');\n    var localOpts = opts;\n    if (width) {\n        localOpts = Utils.clone(opts);\n        localOpts.maxWidth = width;\n    }\n    // pass along rootSrc if defined on `picture` element\n    ResizeImages._rewriteSrcAttribute(element, localOpts, rootSrc);\n};\n\n/**\n * Takes a picture element and calls _resizeSourceElement on its `<source />` \n * children\n */\nResizeImages._crawlPictureElement = function(el, opts) {\n    var sources = el.getElementsByTagName('source');\n    // If source elements are erased from the dom, leave the\n    // picture element alone.\n    if (sources.length === 0 || el.hasAttribute('mobify-optimized')) {\n        return;\n    }\n    el.setAttribute('mobify-optimized', '');\n\n    // Grab optional `data-src` attribute on `picture`.\n    // Used for preventing writing the same src multiple times for\n    // different `source` elements.\n    var rootSrc = el.getAttribute('data-src');\n\n    // resize the sources\n    for(var i =  0, len = sources.length; i < len; i++) {\n        ResizeImages._resizeSourceElement(sources[i], opts, rootSrc);\n    }\n};\n\n/**\n * Searches a list of target dimensions for the smallest one that is greater than \n * the passed value and return it, or return the greatst value if none are \n * greater.\n *\n * Popular device resolutions: \n * iPhone 3Gs - 320x480\n * iPhone 4 - 640x960\n * iPhone 5 - 650x1156\n * \n * Galaxy SIII/Nexus 4/Nexus 7 - 720x1280\n * Galaxy SIV/Nexus 5 - 1080x1920\n * \n * iPad (non-retina) - 1024x768\n * iPad (retina) - 2048x1536\n *\n * A larger list of target dimensions would include 720px, 800px, 1024px, 1280px \n * and 1920px but they have been omitted due tot heir proximity to other, larger \n * values\n */\nvar targetDims = [320, 640, 768, 1080, 1536, 2048, 4000];\nResizeImages._getBinnedDimension = function(dim) {\n    var resultDim = 0;\n\n    for (var i = 0, len = targetDims.length; i < len; i++) {\n        resultDim = targetDims[i];\n        if (resultDim >= dim) {\n            break;\n        }\n    }\n    return resultDim;\n};\n\n/**\n * Returns a boolean that indicates whether images should be resized.\n * Looks for the viewport meta tag and parses it to determine whether the\n * website is responsive (the viewport is set to the device's width). This\n * ensures that images that are part of a larger viewport are not scaled.\n */\nResizeImages._shouldResize = function(document) {\n    var metaViewport = Utils.getMetaViewportProperties(document);\n    if (!metaViewport) {\n        return false;\n    }\n\n    // It's complicated, but what we want to know is whether the viewport\n    // matches the 'ideal viewport'. If either `initial-scale` is 1 or `width`\n    // is device-width or both, then the viewport will match the 'ideal\n    // viewport'. There are a few other special circumstances under which the\n    // viewport could be ideal, but we can't test for them.\n    //\n    // See: http://www.quirksmode.org/mobile/metaviewport/\n\n    // Ideal viewport when width=device-width\n    if (!metaViewport['initial-scale'] && metaViewport['width']) {\n        return metaViewport['width'] == 'device-width';\n    }\n\n    // Ideal viewport when initial-scale=1\n    if (!metaViewport['width'] && metaViewport['initial-scale']) {\n        return metaViewport['initial-scale'] == '1';\n    }\n\n    // Ideal viewport when width=device-width and the intial-scale is 1 or more\n    // (in that case it's just zoomed)\n    if (metaViewport['width'] && metaViewport['initial-scale']) {\n        initialScale = parseInt(metaViewport['initial-scale'], 10);\n        return initialScale >= 1 && metaViewport['width'] == 'device-width';\n    }\n\n    return false;\n};\n\n/**\n * Processes options passed to `resize()`. Takes an options object that \n * potentially has height and width set in css pixels, returns an object where \n * they are expressed in device pixels, and other default options are set.\n */\nResizeImages.processOptions = function(options) {\n    var opts = Utils.clone(ResizeImages.defaults);\n    if (options) {\n        Utils.extend(opts, options);\n    }\n\n    // A null value for `resize` triggers the auto detect functionality. This\n    // uses the document to determine whether images should be resized and sets\n    // it as the new default.\n    if (opts.resize === null && options.document) {\n        var resize = ResizeImages._shouldResize(options.document);\n        ResizeImages.defaults.resize = opts.resize = resize;\n    }\n\n    if (!opts.format && opts.webp) {\n        opts.format = \"webp\";\n    }\n\n    // Without `resize` images are served through IR without changing their dimensions\n    if (!opts.resize) {\n        opts.maxWidth = opts.maxHeight = opts.devicePixelRatio = null;\n    }\n    else {\n        var dpr = opts.devicePixelRatio || window.devicePixelRatio;\n\n        var screenSize = Utils.getPhysicalScreenSize(dpr);\n\n        // If maxHeight/maxWidth are not specified, use screen dimensions\n        // in device pixels\n        var width = opts.maxWidth || ResizeImages._getBinnedDimension(screenSize.width);\n        var height = opts.maxHeight || undefined;\n\n        // Otherwise, compute device pixels\n        if (dpr && opts.maxWidth) {\n            width = width * dpr;\n            if (opts.maxHeight) {\n                height = height * dpr;\n            }\n        }\n\n        // round up in case of non-integer device pixel ratios\n        opts.maxWidth = Math.ceil(width);\n        if (opts.maxHeight && height) {\n            opts.maxHeight = Math.ceil(height);\n        }\n    }\n\n    return opts;\n};\n\n/**\n * Searches the collection for image elements and modifies them to use\n * the Image Resize service. Pass `options` to modify how the images are \n * resized.\n */\nResizeImages.resize = function(elements, options) {\n    // Return early if elements is empty\n    if (!elements.length) {\n        return;\n    }\n\n    // Supplement `options` with the document from the first element\n    if (options && !options.document) {\n        options.document = elements[0].ownerDocument;\n    }\n    var opts = ResizeImages.processOptions(options);\n\n    for(var i=0; i < elements.length; i++) {\n        var element = elements[i];\n\n        // For an `img`, simply modify the src attribute\n        if (element.nodeName === 'IMG' && !element.hasAttribute('mobify-optimized')) {\n            element.setAttribute('mobify-optimized', '');\n            ResizeImages._rewriteSrcAttribute(element, opts);\n        }\n        // For a `picture`, (potentially) nuke src on `img`, and\n        // pass all `source` elements into modifyImages recursively\n        else if (element.nodeName === 'PICTURE') {\n            ResizeImages._crawlPictureElement(element, opts);\n        }\n    }\n\n    return elements;\n};\n\nResizeImages.restoreOriginalSrc = function(event) {\n    var origSrc;\n    event.target.removeAttribute('onerror'); // remove ourselves\n    origSrc = event.target.getAttribute('data-orig-src');\n    if (origSrc) {\n        event.target.setAttribute('src', origSrc);\n    }\n};\n\nvar capturing = window.Mobify && window.Mobify.capturing || false;\n\nResizeImages.defaults = {\n    cacheHours: 8,\n    proto: '//',\n    host: 'ir0.mobify.com',\n    projectName: \"oss-\" + location.hostname.replace(/[^\\w]/g, '-'),\n    sourceAttribute: \"x-src\",\n    targetAttribute: (capturing ? \"x-src\" : \"src\"),\n    webp: ResizeImages.supportsWebp(),\n    resize: true,\n    onerror: 'ResizeImages.restoreOriginalSrc(event);'\n};\n\nResizeImages.profiles = {\n    SHORT_CACHE: {\n        cacheHours: 2\n    },\n    LONG_CACHE: {\n        cacheHours: 168\n    }\n};\n\nreturn ResizeImages;\n}));\n\n",
    "define('text',{});\n",
    "define('json',{load: function(id){throw new Error(\"Dynamic load not allowed: \" + id);}});\n",
    "\ndefine(\"json!package\", function(){ return {\n    \"name\": \"template-split\",\n    \"siteUrl\": \"\",\n    \"version\": \"0.0.1\",\n    \"dependencies\": {\n        \"adaptivejs\": \"1.2.0\",\n        \"connect\": \"2.3.4\",\n        \"grunt\": \"0.4.2\",\n        \"grunt-concurrent\": \"0.4.3\",\n        \"mocha\": \"1.14.0\",\n        \"chai\": \"1.9.0\",\n        \"mobify-chai-assertions\": \"^1.0.0\",\n        \"lodash\": \"~2.4.1\",\n        \"grunt-contrib-sass\": \"0.8.1\",\n        \"grunt-autoprefixer\": \"2.0.0\",\n        \"nightwatch\": \"0.5.36\",\n        \"nightwatch-commands\": \"1.0.0\",\n        \"grunt-eslint\": \"^2.1.0\",\n        \"mobify-code-style\": \"2.0.1\"\n}\n}\n;});\n\n",
    "define('adaptivejs/defaults',[\n    'adaptivejs/utils',\n    'json!package'\n], function(Utils, package) {\n    var projectName;\n\n    try {\n        projectName = package.name;\n    } catch (e) {\n        console.error('Couldn\\'t determine the project name. Be sure that is in defined in the package.json file.');\n    }\n\n    /**\n     *  Returns an object with some useful defaults that can be used\n     *  to build up a more complex context\n     */\n    function getContext() {\n        var defaultContext = {};\n        var config = {};\n\n        config.projectName = projectName;\n        config.isDebug = Utils.isDebug();\n        config.adaptiveBuildScript = Utils.getAdaptiveBuildScript();\n        config.adaptiveBuild = config.adaptiveBuildScript && config.adaptiveBuildScript.getAttribute('src');\n        config.buildOrigin = Utils.getBuildOrigin();\n        config.ajs = function(context) {\n            return Utils.getAjs(config.projectName, context.templateName);\n        };\n\n        defaultContext.config = config;\n        return defaultContext;\n    }\n\n    return {\n        'projectName': projectName,\n        'getContext': getContext\n    };\n\n});\n\n",
    "define('includes/_header',['$'], function($) {\n    return {\n        context: {\n            title: function() {\n                var $title = $('title');\n                return $title.length > 0 ? $title.text() : 'no title found';\n            }\n        }\n    };\n});\n\n",
    "define('includes/_footer',['$'], function($) {\n    return {\n        context: {\n            documentationLink: function() {\n                return {\n                    text: 'Adaptive.js Documentation',\n                    href: 'https://cloud.mobify.com/docs/adaptivejs/'\n                };\n            }\n        }\n    };\n});\n\n",
    "define('dust',{load: function(id){throw new Error(\"Dynamic load not allowed: \" + id);}});\n",
    "/*! Dust - Asynchronous Templating - v2.3.3\n* http://linkedin.github.io/dustjs/\n* Copyright (c) 2014 Aleksander Williams; Released under the MIT License */\n(function(root) {\n  var dust = {},\n      NONE = 'NONE',\n      ERROR = 'ERROR',\n      WARN = 'WARN',\n      INFO = 'INFO',\n      DEBUG = 'DEBUG',\n      loggingLevels = [DEBUG, INFO, WARN, ERROR, NONE],\n      EMPTY_FUNC = function() {},\n      logger = EMPTY_FUNC,\n      loggerContext = this;\n\n  dust.debugLevel = NONE;\n  dust.silenceErrors = false;\n\n  // Try to find the console logger in global scope\n  if (root && root.console && root.console.log) {\n    logger = root.console.log;\n    loggerContext = root.console;\n  }\n\n  /**\n   * If dust.isDebug is true, Log dust debug statements, info statements, warning statements, and errors.\n   * This default implementation will print to the console if it exists.\n   * @param {String|Error} message the message to print/throw\n   * @param {String} type the severity of the message(ERROR, WARN, INFO, or DEBUG)\n   * @public\n   */\n  dust.log = function(message, type) {\n    if(dust.isDebug && dust.debugLevel === NONE) {\n      logger.call(loggerContext, '[!!!DEPRECATION WARNING!!!]: dust.isDebug is deprecated.  Set dust.debugLevel instead to the level of logging you want [\"debug\",\"info\",\"warn\",\"error\",\"none\"]');\n      dust.debugLevel = INFO;\n    }\n\n    type = type || INFO;\n    if (loggingLevels.indexOf(type) >= loggingLevels.indexOf(dust.debugLevel)) {\n      if(!dust.logQueue) {\n        dust.logQueue = [];\n      }\n      dust.logQueue.push({message: message, type: type});\n      logger.call(loggerContext, '[DUST ' + type + ']: ' + message);\n    }\n\n    if (!dust.silenceErrors && type === ERROR) {\n      if (typeof message === 'string') {\n        throw new Error(message);\n      } else {\n        throw message;\n      }\n    }\n  };\n\n  /**\n   * If debugging is turned on(dust.isDebug=true) log the error message and throw it.\n   * Otherwise try to keep rendering.  This is useful to fail hard in dev mode, but keep rendering in production.\n   * @param {Error} error the error message to throw\n   * @param {Object} chunk the chunk the error was thrown from\n   * @public\n   */\n  dust.onError = function(error, chunk) {\n    logger.call(loggerContext, '[!!!DEPRECATION WARNING!!!]: dust.onError will no longer return a chunk object.');\n    dust.log(error.message || error, ERROR);\n    if(!dust.silenceErrors) {\n      throw error;\n    } else {\n      return chunk;\n    }\n  };\n\n  dust.helpers = {};\n\n  dust.cache = {};\n\n  dust.register = function(name, tmpl) {\n    if (!name) {\n      return;\n    }\n    dust.cache[name] = tmpl;\n  };\n\n  dust.render = function(name, context, callback) {\n    var chunk = new Stub(callback).head;\n    try {\n      dust.load(name, chunk, Context.wrap(context, name)).end();\n    } catch (err) {\n      dust.log(err, ERROR);\n    }\n  };\n\n  dust.stream = function(name, context) {\n    var stream = new Stream();\n    dust.nextTick(function() {\n      try {\n        dust.load(name, stream.head, Context.wrap(context, name)).end();\n      } catch (err) {\n        dust.log(err, ERROR);\n      }\n    });\n    return stream;\n  };\n\n  dust.renderSource = function(source, context, callback) {\n    return dust.compileFn(source)(context, callback);\n  };\n\n  dust.compileFn = function(source, name) {\n    // name is optional. When name is not provided the template can only be rendered using the callable returned by this function.\n    // If a name is provided the compiled template can also be rendered by name.\n    name = name || null;\n    var tmpl = dust.loadSource(dust.compile(source, name));\n    return function(context, callback) {\n      var master = callback ? new Stub(callback) : new Stream();\n      dust.nextTick(function() {\n        if(typeof tmpl === 'function') {\n          tmpl(master.head, Context.wrap(context, name)).end();\n        }\n        else {\n          dust.log(new Error('Template [' + name + '] cannot be resolved to a Dust function'), ERROR);\n        }\n      });\n      return master;\n    };\n  };\n\n  dust.load = function(name, chunk, context) {\n    var tmpl = dust.cache[name];\n    if (tmpl) {\n      return tmpl(chunk, context);\n    } else {\n      if (dust.onLoad) {\n        return chunk.map(function(chunk) {\n          dust.onLoad(name, function(err, src) {\n            if (err) {\n              return chunk.setError(err);\n            }\n            if (!dust.cache[name]) {\n              dust.loadSource(dust.compile(src, name));\n            }\n            dust.cache[name](chunk, context).end();\n          });\n        });\n      }\n      return chunk.setError(new Error('Template Not Found: ' + name));\n    }\n  };\n\n  dust.loadSource = function(source, path) {\n    return eval(source);\n  };\n\n  if (Array.isArray) {\n    dust.isArray = Array.isArray;\n  } else {\n    dust.isArray = function(arr) {\n      return Object.prototype.toString.call(arr) === '[object Array]';\n    };\n  }\n\n  dust.nextTick = (function() {\n    return function(callback) {\n      setTimeout(callback,0);\n    };\n  } )();\n\n  dust.isEmpty = function(value) {\n    if (dust.isArray(value) && !value.length) {\n      return true;\n    }\n    if (value === 0) {\n      return false;\n    }\n    return (!value);\n  };\n\n  // apply the filter chain and return the output string\n  dust.filter = function(string, auto, filters) {\n    if (filters) {\n      for (var i=0, len=filters.length; i<len; i++) {\n        var name = filters[i];\n        if (name === 's') {\n          auto = null;\n          dust.log('Using unescape filter on [' + string + ']', DEBUG);\n        }\n        else if (typeof dust.filters[name] === 'function') {\n          string = dust.filters[name](string);\n        }\n        else {\n          dust.log('Invalid filter [' + name + ']', WARN);\n        }\n      }\n    }\n    // by default always apply the h filter, unless asked to unescape with |s\n    if (auto) {\n      string = dust.filters[auto](string);\n    }\n    return string;\n  };\n\n  dust.filters = {\n    h: function(value) { return dust.escapeHtml(value); },\n    j: function(value) { return dust.escapeJs(value); },\n    u: encodeURI,\n    uc: encodeURIComponent,\n    js: function(value) {\n      if (!JSON) {\n        dust.log('JSON is undefined.  JSON stringify has not been used on [' + value + ']', WARN);\n        return value;\n      } else {\n        return JSON.stringify(value);\n      }\n    },\n    jp: function(value) {\n      if (!JSON) {dust.log('JSON is undefined.  JSON parse has not been used on [' + value + ']', WARN);\n        return value;\n      } else {\n        return JSON.parse(value);\n      }\n    }\n  };\n\n  function Context(stack, global, blocks, templateName) {\n    this.stack  = stack;\n    this.global = global;\n    this.blocks = blocks;\n    this.templateName = templateName;\n  }\n\n  dust.makeBase = function(global) {\n    return new Context(new Stack(), global);\n  };\n\n  Context.wrap = function(context, name) {\n    if (context instanceof Context) {\n      return context;\n    }\n    return new Context(new Stack(context), {}, null, name);\n  };\n\n  /**\n   * Public API for getting a value from the context.\n   * @method get\n   * @param {string|array} path The path to the value. Supported formats are:\n   * 'key'\n   * 'path.to.key'\n   * '.path.to.key'\n   * ['path', 'to', 'key']\n   * ['key']\n   * @param {boolean} [cur=false] Boolean which determines if the search should be limited to the\n   * current context (true), or if get should search in parent contexts as well (false).\n   * @public\n   * @returns {string|object}\n   */\n  Context.prototype.get = function(path, cur) {\n    if (typeof path === 'string') {\n      if (path[0] === '.') {\n        cur = true;\n        path = path.substr(1);\n      }\n      path = path.split('.');\n    }\n    return this._get(cur, path);\n  };\n\n  /**\n   * Get a value from the context\n   * @method _get\n   * @param {boolean} cur Get only from the current context\n   * @param {array} down An array of each step in the path\n   * @private\n   * @return {string | object}\n   */\n  Context.prototype._get = function(cur, down) {\n    var ctx = this.stack,\n        i = 1,\n        value, first, len, ctxThis;\n    dust.log('Searching for reference [{' + down.join('.') + '}] in template [' + this.getTemplateName() + ']', DEBUG);\n    first = down[0];\n    len = down.length;\n\n    if (cur && len === 0) {\n      ctxThis = ctx;\n      ctx = ctx.head;\n    } else {\n      if (!cur) {\n        // Search up the stack for the first value\n        while (ctx) {\n          if (ctx.isObject) {\n            ctxThis = ctx.head;\n            value = ctx.head[first];\n            if (value !== undefined) {\n              break;\n            }\n          }\n          ctx = ctx.tail;\n        }\n\n        if (value !== undefined) {\n          ctx = value;\n        } else {\n          ctx = this.global ? this.global[first] : undefined;\n        }\n      } else {\n        // if scope is limited by a leading dot, don't search up the tree\n        ctx = ctx.head[first];\n      }\n\n      while (ctx && i < len) {\n        ctxThis = ctx;\n        ctx = ctx[down[i]];\n        i++;\n      }\n    }\n\n    // Return the ctx or a function wrapping the application of the context.\n    if (typeof ctx === 'function') {\n      var fn = function() {\n        try {\n          return ctx.apply(ctxThis, arguments);\n        } catch (err) {\n          return dust.log(err, ERROR);\n        }\n      };\n      fn.isFunction = true;\n      return fn;\n    } else {\n      if (ctx === undefined) {\n        dust.log('Cannot find the value for reference [{' + down.join('.') + '}] in template [' + this.getTemplateName() + ']');\n      }\n      return ctx;\n    }\n  };\n\n  Context.prototype.getPath = function(cur, down) {\n    return this._get(cur, down);\n  };\n\n  Context.prototype.push = function(head, idx, len) {\n    return new Context(new Stack(head, this.stack, idx, len), this.global, this.blocks, this.getTemplateName());\n  };\n\n  Context.prototype.rebase = function(head) {\n    return new Context(new Stack(head), this.global, this.blocks, this.getTemplateName());\n  };\n\n  Context.prototype.current = function() {\n    return this.stack.head;\n  };\n\n  Context.prototype.getBlock = function(key, chk, ctx) {\n    if (typeof key === 'function') {\n      var tempChk = new Chunk();\n      key = key(tempChk, this).data.join('');\n    }\n\n    var blocks = this.blocks;\n\n    if (!blocks) {\n      dust.log('No blocks for context[{' + key + '}] in template [' + this.getTemplateName() + ']', DEBUG);\n      return;\n    }\n    var len = blocks.length, fn;\n    while (len--) {\n      fn = blocks[len][key];\n      if (fn) {\n        return fn;\n      }\n    }\n  };\n\n  Context.prototype.shiftBlocks = function(locals) {\n    var blocks = this.blocks,\n        newBlocks;\n\n    if (locals) {\n      if (!blocks) {\n        newBlocks = [locals];\n      } else {\n        newBlocks = blocks.concat([locals]);\n      }\n      return new Context(this.stack, this.global, newBlocks, this.getTemplateName());\n    }\n    return this;\n  };\n\n  Context.prototype.getTemplateName = function() {\n    return this.templateName;\n  };\n\n  function Stack(head, tail, idx, len) {\n    this.tail = tail;\n    this.isObject = head && typeof head === 'object';\n    this.head = head;\n    this.index = idx;\n    this.of = len;\n  }\n\n  function Stub(callback) {\n    this.head = new Chunk(this);\n    this.callback = callback;\n    this.out = '';\n  }\n\n  Stub.prototype.flush = function() {\n    var chunk = this.head;\n\n    while (chunk) {\n      if (chunk.flushable) {\n        this.out += chunk.data.join(''); //ie7 perf\n      } else if (chunk.error) {\n        this.callback(chunk.error);\n        dust.log('Chunk error [' + chunk.error + '] thrown. Ceasing to render this template.', WARN);\n        this.flush = EMPTY_FUNC;\n        return;\n      } else {\n        return;\n      }\n      chunk = chunk.next;\n      this.head = chunk;\n    }\n    this.callback(null, this.out);\n  };\n\n  function Stream() {\n    this.head = new Chunk(this);\n  }\n\n  Stream.prototype.flush = function() {\n    var chunk = this.head;\n\n    while(chunk) {\n      if (chunk.flushable) {\n        this.emit('data', chunk.data.join('')); //ie7 perf\n      } else if (chunk.error) {\n        this.emit('error', chunk.error);\n        dust.log('Chunk error [' + chunk.error + '] thrown. Ceasing to render this template.', WARN);\n        this.flush = EMPTY_FUNC;\n        return;\n      } else {\n        return;\n      }\n      chunk = chunk.next;\n      this.head = chunk;\n    }\n    this.emit('end');\n  };\n\n  Stream.prototype.emit = function(type, data) {\n    if (!this.events) {\n      dust.log('No events to emit', INFO);\n      return false;\n    }\n    var handler = this.events[type];\n    if (!handler) {\n      dust.log('Event type [' + type + '] does not exist', WARN);\n      return false;\n    }\n    if (typeof handler === 'function') {\n      handler(data);\n    } else if (dust.isArray(handler)) {\n      var listeners = handler.slice(0);\n      for (var i = 0, l = listeners.length; i < l; i++) {\n        listeners[i](data);\n      }\n    } else {\n      dust.log('Event Handler [' + handler + '] is not of a type that is handled by emit', WARN);\n    }\n  };\n\n  Stream.prototype.on = function(type, callback) {\n    if (!this.events) {\n      this.events = {};\n    }\n    if (!this.events[type]) {\n      dust.log('Event type [' + type + '] does not exist. Using just the specified callback.', WARN);\n      if(callback) {\n        this.events[type] = callback;\n      } else {\n        dust.log('Callback for type [' + type + '] does not exist. Listener not registered.', WARN);\n      }\n    } else if(typeof this.events[type] === 'function') {\n      this.events[type] = [this.events[type], callback];\n    } else {\n      this.events[type].push(callback);\n    }\n    return this;\n  };\n\n  Stream.prototype.pipe = function(stream) {\n    this.on('data', function(data) {\n      try {\n        stream.write(data, 'utf8');\n      } catch (err) {\n        dust.log(err, ERROR);\n      }\n    }).on('end', function() {\n      try {\n        return stream.end();\n      } catch (err) {\n        dust.log(err, ERROR);\n      }\n    }).on('error', function(err) {\n      stream.error(err);\n    });\n    return this;\n  };\n\n  function Chunk(root, next, taps) {\n    this.root = root;\n    this.next = next;\n    this.data = []; //ie7 perf\n    this.flushable = false;\n    this.taps = taps;\n  }\n\n  Chunk.prototype.write = function(data) {\n    var taps  = this.taps;\n\n    if (taps) {\n      data = taps.go(data);\n    }\n    this.data.push(data);\n    return this;\n  };\n\n  Chunk.prototype.end = function(data) {\n    if (data) {\n      this.write(data);\n    }\n    this.flushable = true;\n    this.root.flush();\n    return this;\n  };\n\n  Chunk.prototype.map = function(callback) {\n    var cursor = new Chunk(this.root, this.next, this.taps),\n        branch = new Chunk(this.root, cursor, this.taps);\n\n    this.next = branch;\n    this.flushable = true;\n    callback(branch);\n    return cursor;\n  };\n\n  Chunk.prototype.tap = function(tap) {\n    var taps = this.taps;\n\n    if (taps) {\n      this.taps = taps.push(tap);\n    } else {\n      this.taps = new Tap(tap);\n    }\n    return this;\n  };\n\n  Chunk.prototype.untap = function() {\n    this.taps = this.taps.tail;\n    return this;\n  };\n\n  Chunk.prototype.render = function(body, context) {\n    return body(this, context);\n  };\n\n  Chunk.prototype.reference = function(elem, context, auto, filters) {\n    if (typeof elem === 'function') {\n      elem.isFunction = true;\n      // Changed the function calling to use apply with the current context to make sure\n      // that \"this\" is wat we expect it to be inside the function\n      elem = elem.apply(context.current(), [this, context, null, {auto: auto, filters: filters}]);\n      if (elem instanceof Chunk) {\n        return elem;\n      }\n    }\n    if (!dust.isEmpty(elem)) {\n      return this.write(dust.filter(elem, auto, filters));\n    } else {\n      return this;\n    }\n  };\n\n  Chunk.prototype.section = function(elem, context, bodies, params) {\n    // anonymous functions\n    if (typeof elem === 'function') {\n      elem = elem.apply(context.current(), [this, context, bodies, params]);\n      // functions that return chunks are assumed to have handled the body and/or have modified the chunk\n      // use that return value as the current chunk and go to the next method in the chain\n      if (elem instanceof Chunk) {\n        return elem;\n      }\n    }\n    var body = bodies.block,\n        skip = bodies['else'];\n\n    // a.k.a Inline parameters in the Dust documentations\n    if (params) {\n      context = context.push(params);\n    }\n\n    /*\n    Dust's default behavior is to enumerate over the array elem, passing each object in the array to the block.\n    When elem resolves to a value or object instead of an array, Dust sets the current context to the value\n    and renders the block one time.\n    */\n    //non empty array is truthy, empty array is falsy\n    if (dust.isArray(elem)) {\n      if (body) {\n        var len = elem.length, chunk = this;\n        if (len > 0) {\n          // any custom helper can blow up the stack\n          // and store a flattened context, guard defensively\n          if(context.stack.head) {\n            context.stack.head['$len'] = len;\n          }\n          for (var i=0; i<len; i++) {\n            if(context.stack.head) {\n              context.stack.head['$idx'] = i;\n            }\n            chunk = body(chunk, context.push(elem[i], i, len));\n          }\n          if(context.stack.head) {\n            context.stack.head['$idx'] = undefined;\n            context.stack.head['$len'] = undefined;\n          }\n          return chunk;\n        }\n        else if (skip) {\n          return skip(this, context);\n        }\n      }\n    } else if (elem  === true) {\n     // true is truthy but does not change context\n      if (body) {\n        return body(this, context);\n      }\n    } else if (elem || elem === 0) {\n       // everything that evaluates to true are truthy ( e.g. Non-empty strings and Empty objects are truthy. )\n       // zero is truthy\n       // for anonymous functions that did not returns a chunk, truthiness is evaluated based on the return value\n      if (body) {\n        return body(this, context.push(elem));\n      }\n     // nonexistent, scalar false value, scalar empty string, null,\n     // undefined are all falsy\n    } else if (skip) {\n      return skip(this, context);\n    }\n    dust.log('Not rendering section (#) block in template [' + context.getTemplateName() + '], because above key was not found', DEBUG);\n    return this;\n  };\n\n  Chunk.prototype.exists = function(elem, context, bodies) {\n    var body = bodies.block,\n        skip = bodies['else'];\n\n    if (!dust.isEmpty(elem)) {\n      if (body) {\n        return body(this, context);\n      }\n    } else if (skip) {\n      return skip(this, context);\n    }\n    dust.log('Not rendering exists (?) block in template [' + context.getTemplateName() + '], because above key was not found', DEBUG);\n    return this;\n  };\n\n  Chunk.prototype.notexists = function(elem, context, bodies) {\n    var body = bodies.block,\n        skip = bodies['else'];\n\n    if (dust.isEmpty(elem)) {\n      if (body) {\n        return body(this, context);\n      }\n    } else if (skip) {\n      return skip(this, context);\n    }\n    dust.log('Not rendering not exists (^) block check in template [' + context.getTemplateName() + '], because above key was found', DEBUG);\n    return this;\n  };\n\n  Chunk.prototype.block = function(elem, context, bodies) {\n    var body = bodies.block;\n\n    if (elem) {\n      body = elem;\n    }\n\n    if (body) {\n      return body(this, context);\n    }\n    return this;\n  };\n\n  Chunk.prototype.partial = function(elem, context, params) {\n    var partialContext;\n    //put the params context second to match what section does. {.} matches the current context without parameters\n    // start with an empty context\n    partialContext = dust.makeBase(context.global);\n    partialContext.blocks = context.blocks;\n    if (context.stack && context.stack.tail){\n      // grab the stack(tail) off of the previous context if we have it\n      partialContext.stack = context.stack.tail;\n    }\n    if (params){\n      //put params on\n      partialContext = partialContext.push(params);\n    }\n\n    if(typeof elem === 'string') {\n      partialContext.templateName = elem;\n    }\n\n    //reattach the head\n    partialContext = partialContext.push(context.stack.head);\n\n    var partialChunk;\n    if (typeof elem === 'function') {\n      partialChunk = this.capture(elem, partialContext, function(name, chunk) {\n        partialContext.templateName = partialContext.templateName || name;\n        dust.load(name, chunk, partialContext).end();\n      });\n    } else {\n      partialChunk = dust.load(elem, this, partialContext);\n    }\n    return partialChunk;\n  };\n\n  Chunk.prototype.helper = function(name, context, bodies, params) {\n    var chunk = this;\n    // handle invalid helpers, similar to invalid filters\n    try {\n      if(dust.helpers[name]) {\n        return dust.helpers[name](chunk, context, bodies, params);\n      } else {\n        dust.log('Invalid helper [' + name + ']', WARN);\n        return chunk;\n      }\n    } catch (err) {\n      dust.log(err, ERROR);\n      return chunk;\n    }\n  };\n\n  Chunk.prototype.capture = function(body, context, callback) {\n    return this.map(function(chunk) {\n      var stub = new Stub(function(err, out) {\n        if (err) {\n          chunk.setError(err);\n        } else {\n          callback(out, chunk);\n        }\n      });\n      body(stub.head, context).end();\n    });\n  };\n\n  Chunk.prototype.setError = function(err) {\n    this.error = err;\n    this.root.flush();\n    return this;\n  };\n\n  function Tap(head, tail) {\n    this.head = head;\n    this.tail = tail;\n  }\n\n  Tap.prototype.push = function(tap) {\n    return new Tap(tap, this);\n  };\n\n  Tap.prototype.go = function(value) {\n    var tap = this;\n\n    while(tap) {\n      value = tap.head(value);\n      tap = tap.tail;\n    }\n    return value;\n  };\n\n  var HCHARS = new RegExp(/[&<>\\\"\\']/),\n      AMP    = /&/g,\n      LT     = /</g,\n      GT     = />/g,\n      QUOT   = /\\\"/g,\n      SQUOT  = /\\'/g;\n\n  dust.escapeHtml = function(s) {\n    if (typeof s === 'string') {\n      if (!HCHARS.test(s)) {\n        return s;\n      }\n      return s.replace(AMP,'&amp;').replace(LT,'&lt;').replace(GT,'&gt;').replace(QUOT,'&quot;').replace(SQUOT, '&#39;');\n    }\n    return s;\n  };\n\n  var BS = /\\\\/g,\n      FS = /\\//g,\n      CR = /\\r/g,\n      LS = /\\u2028/g,\n      PS = /\\u2029/g,\n      NL = /\\n/g,\n      LF = /\\f/g,\n      SQ = /'/g,\n      DQ = /\"/g,\n      TB = /\\t/g;\n\n  dust.escapeJs = function(s) {\n    if (typeof s === 'string') {\n      return s\n        .replace(BS, '\\\\\\\\')\n        .replace(FS, '\\\\/')\n        .replace(DQ, '\\\\\"')\n        .replace(SQ, '\\\\\\'')\n        .replace(CR, '\\\\r')\n        .replace(LS, '\\\\u2028')\n        .replace(PS, '\\\\u2029')\n        .replace(NL, '\\\\n')\n        .replace(LF, '\\\\f')\n        .replace(TB, '\\\\t');\n    }\n    return s;\n  };\n\n\n  if (typeof exports === 'object') {\n    module.exports = dust;\n  } else {\n    root.dust = dust;\n  }\n\n})(this);\n\n\ndefine(\"dust-core\", (function (global) {\n    return function () {\n        var ret, fn;\n        return ret || global.dust;\n    };\n}(this)));\n\n",
    "define('dust-custom',['dust-core', 'adaptivejs/utils'], function(dust, Utils) {\n\n    var likeArray = function(candidate) {\n        return (typeof candidate !== 'string') && (typeof candidate.length === 'number') && (!candidate.tagName);\n    };\n\n    var nodeName = function(node) {\n        return node.nodeName.toLowerCase();\n    };\n\n    var escapeQuote = function(s) {\n        return s.replace('\"', '&quot;');\n    };\n\n    /**\n     * Determines if the supplied node is a Node type, or a Node type of the node's window.\n     */\n    var isNode = function(node) {\n        return node instanceof Node ||\n                node && node.ownerDocument && node.ownerDocument.defaultView && (node instanceof node.ownerDocument.defaultView.Node);\n    };\n\n    var oldIsArray = dust.isArray;\n    dust.isArray = function(arr) {\n        return Boolean(arr && arr.appendTo) || oldIsArray(arr);\n    };\n\n    /**\n     *  Return a string for the opening tag of DOMElement `element`.\n     */\n    dust.filters.openTag = function(element) {\n        if (!element) {\n            return '';\n        }\n        if (element.length) {\n            element = element[0];\n        }\n\n        var stringBuffer = [];\n\n        [].forEach.call(element.attributes, function(attr) {\n            stringBuffer.push(' ', attr.name, '=\"', escapeQuote(attr.value), '\"');\n        });\n        return '<' + nodeName(element) + stringBuffer.join('') + '>';\n    };\n\n    /**\n     *  Return a string for the closing tag of DOMElement `element`.\n     */\n    dust.filters.closeTag = function(element) {\n        if (!element) {\n            return '';\n        }\n        if (element.length) {\n            element = element[0];\n        }\n\n        return '</' + nodeName(element) + '>';\n    };\n\n    /**\n     *  Override the behaviour of the default dust.js filter when\n     *  using {key}.\n     */\n    dust.filters.h = function(node) {\n        if (!node) {\n            return '';\n        }\n\n        // Check if the node is a TextNode\n        if (node.nodeType === 3) {\n            if (node.nodeValue) {\n                return node.nodeValue;\n            }\n        }\n\n        if (isNode(node)) {\n            return Utils.outerHTML(node);\n        }\n\n        if (likeArray(node)) {\n            var result = [];\n            for (var i = 0, len = node.length; i < len; i++) {\n                result.push(dust.filters.h(node[i]));\n            }\n            return result.join('');\n        }\n\n        return dust.escapeHtml(node);\n    };\n\n    dust.filters.innerHTML = function(node) {\n        if (!node) {\n            return '';\n        }\n        if (likeArray(node)) {\n            var result = [];\n            for (var i = 0, len = node.length; i < len; i++) {\n                result.push(node[i].innerHTML || node[i].nodeValue);\n            }\n            return result.join('');\n        }\n        else {\n            return node.innerHTML;\n        }\n    };\n\n    // Adds 'count' helper. Like idx, but this one goes to 11. It's 1 higher.\n    dust.helpers.count = function(chunk, context, bodies) {\n        return bodies.block(chunk, context.push(context.stack.index + 1));\n    };\n\n    /**\n     *  Returns a full url for an asset including a cache breaker\n     */\n    dust.helpers.getUrl = function(chunk, context, bodies, params) {\n        var url = Utils.getAssetUrl(params.path, params.baseUrl, params.cacheBreaker);\n        return chunk.write(url);\n    };\n\n    // Override methods in Context and Chunk in order to get chain inheritance,\n    // as well as for adding _SUPER_\n    var Context = dust.makeBase({}).constructor;\n    var Chunk = dust.stream('', {}).head.constructor;\n\n    var oldBlock = Chunk.prototype.block;\n    Chunk.prototype.block = function(elem, context, bodies) {\n        var topElem = elem ? elem.shift() : undefined;\n        if (topElem) {\n            context.global = context.global || {};\n            // Add `_SUPER_` to the block context.\n            context.global._SUPER_ = function(_elem, context, _bodies) {\n                return _elem.block(elem, context, bodies);\n            };\n            context = new context.constructor(context.stack, context.global, context.blocks);\n        }\n\n        return oldBlock.call(this, topElem, context, bodies);\n    };\n\n    Context.prototype.getBlock = function(key, chk, ctx) {\n        if (typeof key === 'function') {\n            var tempChk = new Chunk();\n            key = key(tempChk, this).data.join('');\n        }\n\n        var blocks = this.blocks;\n\n        if (!blocks) {\n            dust.log('No blocks for context[{' + key + '}] in template [' + this.getTemplateName() + ']', 'DEBUG');\n            return;\n        }\n        var newBlocks = [];\n        for (var i = 0, len = blocks.length; i < len; i++) {\n            // Only push the block if it's not undefined\n            blocks[i][key] && newBlocks.push(blocks[i][key]);\n        }\n        return newBlocks;\n    };\n\n    return dust;\n});\n\n",
    "\ndefine('dust!templates/partials/_header',[\"dust-custom\"],function(dust){(function(){dust.register(\"templates/partials/_header\",body_0);function body_0(chk,ctx){return chk.section(ctx._get(false, [\"header\"]),ctx,{\"block\":body_1},null).write(\"\\n\");}function body_1(chk,ctx){return chk.write(\"\\n    \").write(\"<header class=\\\"t-header\\\" role=\\\"banner\\\">\").write(\"\\n        \").write(\"<h1>Welcome to your Adaptive.js site</h1>\").write(\"\\n        \").write(\"<p>As an initial example of content selection, we've selected the title of your site and placed it in _header.dust:</p>\").write(\"\\n        \").write(\"<p class=\\\"c-card\\\">\").write(\"\\n            \").reference(ctx._get(false, [\"title\"]),ctx,\"h\").write(\"\\n        \").write(\"</p>\").write(\"\\n    \").write(\"</header>\").write(\"\\n\");}return body_0;})(); return function(context, callback) {return dust.render(\"templates/partials/_header\", context, callback)}});\n",
    "\ndefine('dust!templates/partials/_footer',[\"dust-custom\"],function(dust){(function(){dust.register(\"templates/partials/_footer\",body_0);function body_0(chk,ctx){return chk.section(ctx._get(false, [\"footer\"]),ctx,{\"block\":body_1},null).write(\"\\n\");}function body_1(chk,ctx){return chk.write(\"\\n    \").write(\"<footer class=\\\"t-footer\\\" role=\\\"contentinfo\\\">\").write(\"\\n        \").write(\"<hr>\").write(\"\\n        \").write(\"<h3>Documentation</h3>\").write(\"\\n        \").write(\"<div>\").write(\"\\n            \").write(\"<p>For more in-depth information, including API documentation, please visit our \").section(ctx._get(false, [\"documentationLink\"]),ctx,{\"block\":body_2},null).write(\"</p>\").write(\"\\n        \").write(\"</div>\").write(\"\\n    \").write(\"</footer>\").write(\"\\n\");}function body_2(chk,ctx){return chk.write(\"<a href=\\\"\").reference(ctx._get(false, [\"href\"]),ctx,\"h\").write(\"\\\"><b>\").reference(ctx._get(false, [\"text\"]),ctx,\"h\").write(\"</b></a>\");}return body_0;})(); return function(context, callback) {return dust.render(\"templates/partials/_footer\", context, callback)}});\n",
    "\ndefine('dust!templates/base',[\"dust-custom\",\"dust!templates/partials/_header\",\"dust!templates/partials/_footer\"],function(dust){(function(){dust.register(\"templates/base\",body_0);function body_0(chk,ctx){return chk.write(\"<!DOCTYPE html>\").write(\"\\n\").reference(ctx._get(false, [\"html\"]),ctx,\"h\",[\"openTag\",\"s\"]).write(\"\\n\").reference(ctx._get(false, [\"head\"]),ctx,\"h\",[\"openTag\",\"s\"]).write(\"\\n    \").reference(ctx._get(false,[\"config\",\"adaptiveBuildScript\"]),ctx,\"h\").write(\"\\n    \").block(ctx.getBlock(\"head\"),ctx,{\"block\":body_1},null).write(\"\\n\").write(\"</head>\").write(\"\\n\").reference(ctx._get(false, [\"body\"]),ctx,\"h\",[\"openTag\",\"s\"]).write(\"\\n    \").block(ctx.getBlock(\"bodyBlock\"),ctx,{\"block\":body_3},null).write(\"\\n    \").block(ctx.getBlock(\"scripts\"),ctx,{\"block\":body_5},null).write(\"\\n\").write(\"</body>\").write(\"\\n\").write(\"</html>\").write(\"\\n\");}function body_1(chk,ctx){return chk.write(\"\\n        \").reference(ctx._get(false, [\"head\"]),ctx,\"h\",[\"innerHTML\",\"s\"]).write(\"\\n\\n        \").block(ctx.getBlock(\"style\"),ctx,{\"block\":body_2},null).write(\"\\n\\n        \").write(\"<meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no\\\">\").write(\"\\n\\n        \").write(\"\\n        \").reference(ctx._get(false,[\"config\",\"ajs\"]),ctx,\"h\",[\"s\"]).write(\"\\n        \").write(\"<script>\").write(\"\\n            \").write(\"var analytics = Mobify.analytics = Mobify.analytics || {};\").write(\"\\n            \").write(\"analytics.ga = analytics.ga || [];\").write(\"\\n            \").write(\"analytics.ua = analytics.ua || function() {\").write(\"\\n                \").write(\"(analytics.ua.q = analytics.ua.q || []).push(arguments);\").write(\"\\n            \").write(\"};\").write(\"\\n        \").write(\"</script>\").write(\"\\n    \");}function body_2(chk,ctx){return chk.write(\"\\n            \").write(\"<link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"\").helper(\"getUrl\",ctx,{},{\"path\":\"css/stylesheet.css\"}).write(\"\\\" />\").write(\"\\n        \");}function body_3(chk,ctx){return chk.write(\"\\n        \").write(\"<div id=\\\"x-root\\\" class=\\\"t-\").reference(ctx._get(false, [\"templateName\"]),ctx,\"h\").write(\"\\\">\").write(\"\\n\\n            \").partial(\"templates/partials/_header\",ctx,null).write(\"\\n\\n            \").write(\"<main class=\\\"t-main\\\" role=\\\"main\\\">\").write(\"\\n                \").block(ctx.getBlock(\"contentBlock\"),ctx,{\"block\":body_4},null).write(\"\\n            \").write(\"</main>\").write(\"\\n\\n            \").partial(\"templates/partials/_footer\",ctx,null).write(\"\\n        \").write(\"</div>\").write(\"\\n    \");}function body_4(chk,ctx){return chk.write(\"\\n                    \").reference(ctx._get(false, [\"body\"]),ctx,\"h\",[\"innerHTML\",\"s\"]).write(\"\\n                \");}function body_5(chk,ctx){return chk.write(\"\\n        \").reference(ctx._get(false, [\"desktopScripts\"]),ctx,\"h\").write(\"\\n\\n        \").write(\"\\n        \").exists(ctx._get(false,[\"config\",\"isDebug\"]),ctx,{\"else\":body_6,\"block\":body_7},null).write(\"\\n\\n        \").block(ctx.getBlock(\"uiScripts\"),ctx,{\"block\":body_8},null).write(\"\\n    \");}function body_6(chk,ctx){return chk.write(\"\\n            \").write(\"<script src=\\\"\").helper(\"getUrl\",ctx,{},{\"path\":\"js/ui.min.js\"}).write(\"\\\"></script>\").write(\"\\n        \");}function body_7(chk,ctx){return chk.write(\"\\n            \").write(\"<script src=\\\"\").helper(\"getUrl\",ctx,{},{\"path\":\"js/ui.js\"}).write(\"\\\"></script>\").write(\"\\n        \");}function body_8(chk,ctx){return chk;}return body_0;})(); return function(context, callback) {return dust.render(\"templates/base\", context, callback)}});\n",
    "define('devSettings',[], function() {\n    /**\n     * WARNING:\n     * The following object will only be used during local development.\n     * When creating the production build, it will be stripped out,\n     * and on the Mobify Cloud, production setting will be injected.\n     */\n    return {\n        cacheBreaker: 11235813 // ensure this is an integer value,\n    };\n});\n\n",
    "define('settings',['devSettings'], function(devSettings) {\n    // Ensure that the object returned only contains values that\n    // are valid JSON-serializable values.\n    try {\n        return JSON.parse(JSON.stringify(devSettings));\n    } catch (e) {\n        console.error('Your Adaptive Settings must return valid JSON!');\n        return {};\n    }\n});\n\n",
    "define('views/base',[\n    '$',\n    'resizeImages',\n    'adaptivejs/utils',\n    'adaptivejs/defaults',\n    'includes/_header',\n    'includes/_footer',\n    'dust!templates/base',\n    'settings'\n],\nfunction($, ResizeImages, Utils, Defaults, header, footer, template, Settings) {\n\n    /**\n     * Grab the default cache breaker variable from the Mobify Config\n     */\n    if (ResizeImages && Settings) {\n        ResizeImages.defaults.cacheBreaker = Settings.cacheBreaker;\n    }\n\n    /**\n     *  Grabs the images which you would like to run through\n     *  imageResizer and sends them away. Can be setup\n     *  with more profiles for different types of images\n     *  if needed.\n     */\n    var resizeImages = function() {\n        var $imgs = $('img');\n        var defaultOpts = {\n            projectName: Defaults.projectName\n        };\n\n        ResizeImages.resize($imgs, defaultOpts);\n\n        return $imgs;\n    };\n\n    return {\n        template: template,\n        includes: {\n            header: header,\n            footer: footer\n        },\n        /**\n        * preProcess receives a context as a paramater and should return\n        * that context with any modifications the user needs. This runs\n        * before keys in `context` are executed\n        */\n        preProcess: function(context) {\n            // Transforms should take place here rather then within `context`.\n            // An example of a DOM transform:\n            $('head').find('meta[name=\"viewport\"]').remove();\n            $('style, link[rel=\"stylesheet\"]').remove();\n\n            return context;\n        },\n\n        /**\n        * postProcess receives a context as a paramater and should return\n        * that context with any modifications the user needs. This runs\n        * after keys in `context` are executed\n        */\n        postProcess: function(context) {\n            // Transforms should take place here rather then within `context`.\n            // An example of a DOM transform:\n            context.desktopScripts = $('script').remove();\n\n            // Uncomment the following line to use Mobify's image resizer:\n            // resizeImages();\n\n            return context;\n        },\n        context: {\n            templateName: 'base',\n            html: function() {\n                return $('html');\n            },\n            head: function() {\n                return $('head');\n            },\n            body: function() {\n                return $('body');\n            }\n        }\n    };\n});\n\n",
    "/**\n * SplitTest, A library for creating and persisting splits\n * for A/B testing\n */\n(function(root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define('split-test',[], factory);\n    } else if (typeof exports === 'object') {\n        // Node. Does not work with strict CommonJS, but\n        // only CommonJS-like environments that support module.exports,\n        // like Node.\n        module.exports = factory();\n    } else {\n        // Browser globals (root is window)\n        root.SplitTest = factory();\n    }\n}(this, function() {\n\n    var SplitTest = function(values, options) {\n        options = options || {};\n        this.cookieName = 'split';\n        if (options.namespace) {\n            this.cookieName = options.namespace + '-' + this.cookieName;\n        }\n\n        this.cookieDomain = options.cookieDomain || window.location.hostname;\n\n        var splitValue = this.getValue();\n\n        if (!splitValue) {\n            splitValue = SplitTest.randomChoice(values);\n            this.setValue(splitValue);\n        }\n    };\n\n    /**\n     * Allows you to enter split parameters and\n     * probabilities. Sets the current split value only\n     * if a current split is not in effect.\n     * Total probability will be normalized to 1.\n     *\n     * Usage:\n     *  var split = SplitTest.init({\n     *      \"A\": 0.1,\n     *      \"B\": 0.9\n     *  }, {\n     *      namespace: \"mobify\",\n     *      lifetime: 15*24*3600 // 15 days in seconds\n     *  });\n     *\n     *  splitVal = split.getValue();\n     */\n    SplitTest.init = function(values, options) {\n        return new SplitTest(values, options);\n    };\n\n    /**\n     * Allows you to explicitly set the split value.\n     * '' (the empty string) is the default state. It will be overridden\n     * by calls to randomChoice(), for example.\n     *\n     */\n    SplitTest.prototype.setChoice = SplitTest.prototype.setValue = function(value) {\n        // Splits are stored for 30 days.\n        SplitTest.setCookie(this.cookieName, value, this.cookieDomain);\n    };\n\n    /**\n     * Returns the current split stored in the cookie\n     */\n    SplitTest.prototype.getChoice = SplitTest.prototype.getValue = function() {\n        var splitValue = SplitTest.getCookie(this.cookieName);\n\n        if (splitValue) {\n            // Push the session out 30 days\n            this.setValue(splitValue);\n        }\n\n        return splitValue;\n    };\n\n    /**\n     * Returns a random choice from the given values\n     * where values is a dictionary of (option, weight)\n     */\n    SplitTest.randomChoice = function(values) {\n        var choices = [];\n        var cumProbabilities = [];\n        var total = 0;\n\n        for (var value in values) {\n            if (values.hasOwnProperty(value)) {\n                total += values[value];\n                choices.push(value);\n                cumProbabilities.push(total);\n            }\n        }\n\n        var pick = Math.random() * total;\n        for (var i = 0, len = choices.length; i < len; i++) {\n            var cumP = cumProbabilities[i];\n            if (cumP > pick) {\n                return choices[i];\n            }\n        }\n    };\n\n    /**\n     * Reads a cookie with the given name.\n     */\n    SplitTest.getCookie = function(name) {\n        var cookieRe = new RegExp(name + '=([^;]+)');\n        var match = cookieRe.exec(document.cookie);\n\n        return (match ? match[1] : '');\n    };\n\n    /**\n     * Sets a cookie with the given name and value.\n     * If a lifetime value is given, the expiry will be set to lifetime\n     * seconds in the future. Otherwise, the expiry is 30 days.\n     *\n     * If domain is given, the cookie is set with that domain.\n     */\n    SplitTest.setCookie = function(name, value, domain, lifetime) {\n        var expires = new Date();\n        var now = (+expires); //type coerce to timestamp\n\n        if (lifetime > 0) {\n            // Lifetime (seconds) in to the future\n            expires.setTime(now + lifetime * 1000);\n        } else {\n            // 30 Days in to the future\n            expires.setTime(now + 30 * 24 * 3600 * 1000);\n        }\n        document.cookie = name + '=' + value + '; expires=' +\n        expires.toGMTString() + '; path=/; ' + (domain && domain !== 'localhost' ? 'domain=' + domain : '');\n    };\n\n    return SplitTest;\n}));\n\n",
    "\ndefine('dust!templates/home1',[\"dust-custom\",\"dust!templates/base\"],function(dust){(function(){dust.register(\"templates/home1\",body_0);var blocks={\"contentBlock\":body_1,\"uiScripts\":body_2};function body_0(chk,ctx){ctx=ctx.shiftBlocks(blocks);return chk.partial(\"templates/base\",ctx,null).write(\"\\n\\n\").write(\"\\n\\n\").write(\"\\n\\n\");}function body_1(chk,ctx){ctx=ctx.shiftBlocks(blocks);return chk.write(\"\\n    \").write(\"<h1>HOME Version 1</h1>\").write(\"\\n    \").write(\"<p>We've also extracted the first paragraph from your site and placed it in home.dust:</p>\").write(\"\\n    \").write(\"<p class=\\\"c-card\\\">\").write(\"\\n        \").reference(ctx._get(false, [\"firstp\"]),ctx,\"h\").write(\"\\n    \").write(\"</p>\").write(\"\\n\");}function body_2(chk,ctx){ctx=ctx.shiftBlocks(blocks);return chk.write(\"\\n    \").write(\"<script>\").write(\"\\n    \").write(\"// Note: Add any JavaScript that should be run on this page into\").write(\"\\n    \").write(\"// assets/js/ui/view-scripts/home.js\").write(\"\\n    \").write(\"(function(require) {\").write(\"\\n        \").write(\"require([\\\"view-scripts/home\\\"], function(homeUI) {\").write(\"\\n            \").write(\"homeUI();\").write(\"\\n        \").write(\"});\").write(\"\\n    \").write(\"})(Adaptive.AMD.require);\").write(\"\\n    \").write(\"</script>\").write(\"\\n\");}return body_0;})(); return function(context, callback) {return dust.render(\"templates/home1\", context, callback)}});\n",
    "\ndefine('dust!templates/home2',[\"dust-custom\",\"dust!templates/base\"],function(dust){(function(){dust.register(\"templates/home2\",body_0);var blocks={\"contentBlock\":body_1,\"uiScripts\":body_2};function body_0(chk,ctx){ctx=ctx.shiftBlocks(blocks);return chk.partial(\"templates/base\",ctx,null).write(\"\\n\\n\").write(\"\\n\\n\").write(\"\\n\\n\");}function body_1(chk,ctx){ctx=ctx.shiftBlocks(blocks);return chk.write(\"\\n    \").write(\"<h1>HOME Version 2</h1>\").write(\"\\n    \").write(\"<p>We've also extracted the first paragraph from your site and placed it in home.dust:</p>\").write(\"\\n    \").write(\"<p class=\\\"c-card\\\">\").write(\"\\n        \").reference(ctx._get(false, [\"firstp\"]),ctx,\"h\").write(\"\\n    \").write(\"</p>\").write(\"\\n\");}function body_2(chk,ctx){ctx=ctx.shiftBlocks(blocks);return chk.write(\"\\n    \").write(\"<script>\").write(\"\\n    \").write(\"// Note: Add any JavaScript that should be run on this page into\").write(\"\\n    \").write(\"// assets/js/ui/view-scripts/home.js\").write(\"\\n    \").write(\"(function(require) {\").write(\"\\n        \").write(\"require([\\\"view-scripts/home\\\"], function(homeUI) {\").write(\"\\n            \").write(\"homeUI();\").write(\"\\n        \").write(\"});\").write(\"\\n    \").write(\"})(Adaptive.AMD.require);\").write(\"\\n    \").write(\"</script>\").write(\"\\n\");}return body_0;})(); return function(context, callback) {return dust.render(\"templates/home2\", context, callback)}});\n",
    "\ndefine('dust!templates/home3',[\"dust-custom\",\"dust!templates/base\"],function(dust){(function(){dust.register(\"templates/home3\",body_0);var blocks={\"contentBlock\":body_1,\"uiScripts\":body_2};function body_0(chk,ctx){ctx=ctx.shiftBlocks(blocks);return chk.partial(\"templates/base\",ctx,null).write(\"\\n\\n\").write(\"\\n\\n\").write(\"\\n\\n\");}function body_1(chk,ctx){ctx=ctx.shiftBlocks(blocks);return chk.write(\"\\n    \").write(\"<h1>HOME Version 3</h1>\").write(\"\\n    \").write(\"<p>We've also extracted the first paragraph from your site and placed it in home.dust:</p>\").write(\"\\n    \").write(\"<p class=\\\"c-card\\\">\").write(\"\\n        \").reference(ctx._get(false, [\"firstp\"]),ctx,\"h\").write(\"\\n    \").write(\"</p>\").write(\"\\n\");}function body_2(chk,ctx){ctx=ctx.shiftBlocks(blocks);return chk.write(\"\\n    \").write(\"<script>\").write(\"\\n    \").write(\"// Note: Add any JavaScript that should be run on this page into\").write(\"\\n    \").write(\"// assets/js/ui/view-scripts/home.js\").write(\"\\n    \").write(\"(function(require) {\").write(\"\\n        \").write(\"require([\\\"view-scripts/home\\\"], function(homeUI) {\").write(\"\\n            \").write(\"homeUI();\").write(\"\\n        \").write(\"});\").write(\"\\n    \").write(\"})(Adaptive.AMD.require);\").write(\"\\n    \").write(\"</script>\").write(\"\\n\");}return body_0;})(); return function(context, callback) {return dust.render(\"templates/home3\", context, callback)}});\n",
    "define('views/home',[\n    '$',\n    'views/base',\n    'split-test',\n    'dust!templates/home1',\n    'dust!templates/home2',\n    'dust!templates/home3'\n],\nfunction($, BaseView, SplitTest, home1, home2, home3) {\n    var template;\n    var splitTest = SplitTest.init({\n        'home1': 0.2,\n        'home2': 0.6,\n        'home3': 0.2\n    }, {\n        namespace: 'mobify',\n        lifetime: 15 * 24 * 3600 // 15 days in seconds\n    });\n\n    var choice = splitTest.getChoice();\n\n    if (choice === 'home1') {\n        template = home1;\n    } else if (choice === 'home2') {\n        template = home2;\n    } else {\n        template = home3;\n    }\n\n    return {\n        template: template,\n        extend: BaseView,\n        context: {\n            templateName: 'home',\n            firstp: function() {\n                return $('p').first().text() || 'Could not find the first paragraph text in your page';\n            }\n        }\n\n        /**\n         * If you wish to override preProcess/postProcess in this view, have a look at the documentation:\n         * https://cloud.mobify.com/docs/adaptivejs/views/\n         */\n    };\n});\n\n",
    "define('router',[\n    '$',\n    'adaptivejs/router',\n    'views/home'\n],\nfunction($, Router, Home) {\n    var router = new Router();\n\n    router\n        .add(Router.selectorMatch('body.home'), Home)\n        .add(Router.urlMatch('/foo'), Home)\n        .add(function() {return true;}, Home);\n\n    return router;\n});\n\n",
    "// Fixes anchor links (on FF)\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define('mobifyjs/patchAnchorLinks',[\"mobifyjs/utils\"], factory);\n    } else if (typeof exports === 'object') {\n        // Node. Does not work with strict CommonJS, but\n        // only CommonJS-like environments that support module.exports,\n        // like Node.\n        var Utils = require('../bower_components/mobifyjs-utils/utils.js');\n        module.exports = factory(Utils);\n    } else {\n        // Browser globals (root is window)\n        root.Utils = factory(root.Utils);\n    }\n}(this, function (Utils) {\n    var exports = {};\n\n    var isOldFirefox = function(ua) {\n        ua = ua || window.navigator.userAgent;\n        var match = /(firefox|fennec)[\\/\\s](\\d+)/i.exec(ua);\n        if (match) {\n            var version = +match[2];\n            if (version >= 29) {\n                return false;\n            }\n            return true;\n        }\n\n        return false;\n    };\n\n    var _patchAnchorLinks = function(doc) {\n        // Anchor links in FF, after we do `document.open` cause a page\n        // navigation (a refresh) instead of just scrolling the\n        // element in to view.\n        //\n        // So, we prevent the default action on the element, and\n        // then manually scroll it in to view (unless some else already\n        // called prevent default).\n\n        var body = doc.body;\n\n        if (!(body && body.addEventListener)) {\n            // Body is not there or we can't bind as expected.\n            return;\n        }\n\n        var _handler = function(e) {\n            // Handler for all clicks on the page, but only triggers\n            // on proper anchor links.\n\n            var target = e.target;\n\n            var matches = function(el) {\n                return (el.nodeName == \"A\") && (/^#/.test(el.getAttribute('href')));\n            };\n\n            if (!matches(target)) {\n                return;\n            }\n            \n            // Newer browsers support `e.defaultPrevented`. FF 4.0 supports `e.getPreventDefault()`\n            var defaultPrevented = (typeof e.defaultPrevented !== \"undefined\") ?\n                e.defaultPrevented :\n                e.getPreventDefault && e.getPreventDefault();\n\n            if (!defaultPrevented) {\n                // Prevent the default action, which would cause a\n                // page refresh.\n                e.preventDefault();\n\n                // But pretend that we didn't call it.\n                e.defaultPrevented = false;\n\n                // We have to wait and see if anyone else calls\n                // `preventDefault`. If they do, we don't scroll.\n                var scroll = true;\n\n                // Override the `preventDefault` to stop  us from scrolling.\n                e.preventDefault = function() {\n                    e.defaultPrevented = true;\n                    scroll = false;\n                };\n\n                // If no other events call `preventDefault` we manually\n                // scroll to the element in question.\n                setTimeout(function() {\n                    if (scroll) {\n                        _scrollToAnchor(target.getAttribute('href'));\n                    }\n                }, 50);\n            }\n        };\n\n\n        var _scrollToAnchor = function(anchor) {\n            // Scrolls to the element, if any, that matches\n            // the given anchor link (eg, \"#foo\").\n\n            var anchorRe = /^#([^\\s]*)/;\n            var match = anchor.match(anchorRe);\n            var target;\n            \n            // Find the target, if any\n            if (match && match[1] === \"\") {\n                target = doc.body;\n            } else if (match && match[1]) {\n                target = doc.getElementById(match[1]);\n            }\n\n            // Scroll to it, if it exists\n            if (target) {\n                target.scrollIntoView && target.scrollIntoView();\n            }\n        };\n\n        // We have to get the event through bubbling, otherwise\n        // events cancelled by the return value of an onclick\n        // handler are not correctly handled.\n        body.addEventListener('click', _handler, false);\n    };\n\n    var patchAnchorLinks = function() {\n        if (!isOldFirefox()) {\n            return;\n        }\n\n        Utils.waitForReady(document, _patchAnchorLinks);\n    };\n\n    patchAnchorLinks._isOldFirefox = isOldFirefox;\n\n\n    return patchAnchorLinks;\n}));\n\n",
    "(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define('mobifyjs/capture',['mobifyjs/utils', 'mobifyjs/patchAnchorLinks'], factory);\n    } else if (typeof exports === 'object') {\n        // Node. Does not work with strict CommonJS, but\n        // only CommonJS-like environments that support module.exports,\n        // like Node.\n        module.exports = factory(require('../bower_components/mobifyjs-utils/utils.js'), require('./patchAnchorLinks.js'));\n    } else {\n        // Browser globals (root is window)\n        root.Capture = factory(root.Utils, root.patchAnchorLinks);\n    }\n}(this, function (Utils, patchAnchorLinks) {\n\n// ##\n// # Static Variables/Functions\n// ##\n\n// v6 tag backwards compatibility change\nif (window.Mobify && \n    !window.Mobify.capturing &&\n    document.getElementsByTagName(\"plaintext\").length) \n{\n            window.Mobify.capturing = true;\n}\n\nvar openingScriptRe = /(<script[\\s\\S]*?>)/gi;\n\n// Inline styles and scripts are disabled using a unknown type.\nvar tagDisablers = {\n    style: ' media=\"mobify-media\"',\n    script: ' type=\"text/mobify-script\"'\n};\n\nvar tagEnablingRe = new RegExp(Utils.values(tagDisablers).join('|'), 'g');\n\n// Map of all attributes we should disable (to prevent resources from downloading)\nvar disablingMap = {\n    img:    ['src'],\n    source: ['src'],\n    iframe: ['src'],\n    script: ['src', 'type'],\n    link:   ['href'],\n    style:  ['media'],\n};\n\nvar affectedTagRe = new RegExp('<(' + Utils.keys(disablingMap).join('|') + ')([\\\\s\\\\S]*?)>', 'gi');\nvar attributeDisablingRes = {};\nvar attributesToEnable = {};\n\n// Populate `attributesToEnable` and `attributeDisablingRes`.\nfor (var tagName in disablingMap) {\n    if (!disablingMap.hasOwnProperty(tagName)) continue;\n    var targetAttributes = disablingMap[tagName];\n\n    targetAttributes.forEach(function(value) {\n        attributesToEnable[value] = true;\n    });\n\n    // <space><attr>='...'|\"...\"\n    attributeDisablingRes[tagName] = new RegExp(\n        '\\\\s+((?:'\n        + targetAttributes.join('|')\n        + \")\\\\s*=\\\\s*(?:('|\\\")[\\\\s\\\\S]+?\\\\2))\", 'gi');\n}\n\n/**\n * Returns the name of a node (in lowercase)\n */\nfunction nodeName(node) {\n    return node.nodeName.toLowerCase();\n}\n\n/**\n * Escape quotes\n */\nfunction escapeQuote(s) {\n    return s.replace('\"', '&quot;');\n}\n\n\n/**\n * Helper method for looping through and grabbing strings of elements\n * in the captured DOM after plaintext insertion\n */\nfunction extractHTMLStringFromElement(container) {\n    if (!container) return '';\n    return [].map.call(container.childNodes, function(el) {\n        var tagName = nodeName(el);\n        if (tagName == '#comment') return '<!--' + el.textContent + '-->';\n        if (tagName == 'plaintext') return el.textContent;\n        // Don't allow mobify related scripts to be added to the new document\n        if (tagName == 'script' && ((/mobify/.test(el.src) || /mobify/i.test(el.textContent)))) {\n            return '';\n        }\n        return el.outerHTML || el.nodeValue || Utils.outerHTML(el);\n    }).join('');\n}\n\n// cached div used repeatedly to create new elements\nvar cachedDiv = document.createElement('div');\n\n// ##\n// # Constructor\n// ##\nvar Capture = function(sourceDoc, prefix) {\n    this.sourceDoc = sourceDoc;\n    this.prefix = prefix || \"x-\";\n    if (window.Mobify) window.Mobify.prefix = this.prefix;\n};\n\n/**\n * Initiate a buffered capture. `init` is an alias to `initCapture` for\n * backwards compatibility.\n */\nCapture.init = Capture.initCapture = function(callback, doc, prefix) {\n    var doc = doc || document;\n\n    var createCapture = function(callback, doc, prefix) {\n        var capture = new Capture(doc, prefix);\n        var capturedStringFragments = Capture.createDocumentFragmentsStrings(capture.sourceDoc);\n        Utils.extend(capture, capturedStringFragments);\n        var capturedDOMFragments = capture.createDocumentFragments();\n        Utils.extend(capture, capturedDOMFragments);\n        callback(capture);\n    }\n\n    if (Utils.domIsReady(doc)) {\n        createCapture(callback, doc, prefix);\n    }\n    // We may be in \"loading\" state by the time we get here, meaning we are\n    // not ready to capture. Next step after \"loading\" is \"interactive\",\n    // which is a valid state to start capturing on (except IE), and thus when ready\n    // state changes once, we know we are good to start capturing.\n    // Cannot rely on using DOMContentLoaded because this event prematurely fires\n    // for some IE10s.\n    else {\n        var created = false;\n        \n        var create = function() {\n            if (!created) {\n                created = true;\n                iid && clearInterval(iid);\n                createCapture(callback, doc, prefix);\n            }\n        }\n        // backup with polling incase readystatechange doesn't fire\n        // (happens with some Android 2.3 browsers)\n        var iid = setInterval(function(){\n            if (Utils.domIsReady(doc)) {\n                create();\n            }\n        }, 100);\n        doc.addEventListener(\"readystatechange\", create, false);\n\n    }\n};\n\n/**\n * Removes closing tags from the end of an HTML string.\n */\nCapture.removeClosingTagsAtEndOfString = function(html) {\n    var match = html.match(/((<\\/[^>]+>)+)$/);\n    if (!match) return html;\n    return html.substring(0, html.length - match[0].length);\n}\n\nCapture.removeTargetSelf = function(html) {\n    return html.replace(/target=(\"_self\"|\\'_self\\')/gi, '');\n}\n\n/**\n * Grab attributes from a string representation of an elements and clone them into dest element\n */\nCapture.cloneAttributes = function(sourceString, dest) {\n    var match = sourceString.match(/^<(\\w+)([\\s\\S]*)$/i);\n    cachedDiv.innerHTML = '<div' + match[2];\n    [].forEach.call(cachedDiv.firstChild.attributes, function(attr) {\n        try {\n            dest.setAttribute(attr.nodeName, attr.nodeValue);\n        } catch (e) {\n            console.error(\"Error copying attributes while capturing: \", e);\n        }\n    });\n\n    return dest;\n};\n\n/**\n * Returns a string with all external attributes disabled.\n * Includes special handling for resources referenced in scripts and inside\n * comments.\n * Not declared on the prototype so it can be used as a static method.\n */\nCapture.disable = function(htmlStr, prefix) {\n    var self = this;\n    // Disables all attributes in disablingMap by prepending prefix\n    var disableAttributes = (function(){\n        return function(whole, tagName, tail) {\n            lowercaseTagName = tagName.toLowerCase();\n            return result = '<' + lowercaseTagName + (tagDisablers[lowercaseTagName] || '')\n                + tail.replace(attributeDisablingRes[lowercaseTagName], ' ' + prefix + '$1') + '>';\n        }\n    })();\n\n    var splitRe = /(<!--[\\s\\S]*?-->)|(?=<\\/script)/i;\n    var tokens = htmlStr.split(splitRe);\n    var ret = tokens.map(function(fragment) {\n                var parsed\n\n                // Fragment may be empty or just a comment, no need to escape those.\n                if (!fragment) return '';\n                if (/^<!--/.test(fragment)) return fragment;\n\n                // Disable before and the <script> itself.\n                // parsed = [before, <script>, script contents]\n                parsed = fragment.split(openingScriptRe);\n                parsed[0] = parsed[0].replace(affectedTagRe, disableAttributes);\n                if (parsed[1]) parsed[1] = parsed[1].replace(affectedTagRe, disableAttributes);\n                return parsed;\n            });\n\n    return [].concat.apply([], ret).join('');\n};\n\n/**\n * Returns a string with all disabled external attributes enabled.\n * Not declared on the prototype so it can be used as a static method.\n */\nCapture.enable = function(htmlStr, prefix) {\n    var attributeEnablingRe = new RegExp('\\\\s' + prefix + '(' + Utils.keys(attributesToEnable).join('|') + ')', 'gi');\n    return htmlStr.replace(attributeEnablingRe, ' $1').replace(tagEnablingRe, '');\n};\n\n/**\n * Return a string for the opening tag of DOMElement `element`.\n */\nCapture.openTag = function(element) {\n    if (!element) return '';\n    if (element.length) element = element[0];\n\n    var stringBuffer = [];\n\n    [].forEach.call(element.attributes, function(attr) {\n        stringBuffer.push(' ', attr.name, '=\"', escapeQuote(attr.value), '\"');\n    })\n\n    return '<' + nodeName(element) + stringBuffer.join('') + '>';\n};\n\n/**\n * Set the content of an element with html from a string\n */\nCapture.setElementContentFromString = function(el, htmlString) {\n    for (cachedDiv.innerHTML = htmlString; cachedDiv.firstChild; el.appendChild(cachedDiv.firstChild));\n};\n\n/**\n * Returns an object containing the state of the original page. Caches the object\n * in `extractedHTML` for later use.\n */\n Capture.createDocumentFragmentsStrings = function(doc) {\n    var headEl = doc.getElementsByTagName('head')[0] || doc.createElement('head');\n    var bodyEl = doc.getElementsByTagName('body')[0] || doc.createElement('body');\n    var htmlEl = doc.getElementsByTagName('html')[0];\n\n    var captured = {\n        doctype: Utils.getDoctype(doc),\n        htmlOpenTag: Capture.openTag(htmlEl),\n        headOpenTag: Capture.openTag(headEl),\n        bodyOpenTag: Capture.openTag(bodyEl),\n        headContent: extractHTMLStringFromElement(headEl),\n        bodyContent: extractHTMLStringFromElement(bodyEl)\n    };\n\n    /**\n     * RR: I assume that Mobify escaping tag is placed in <head>. If so, the <plaintext>\n     * it emits would capture the </head><body> boundary, as well as closing </body></html>\n     * Therefore, bodyContent will have these tags, and they do not need to be added to .all()\n     */\n    captured.all = function(inject) {\n        return this.doctype + this.htmlOpenTag + this.headOpenTag + (inject || '') + this.headContent + this.bodyOpenTag + this.bodyContent;\n    };\n\n    // During capturing, we will usually end up hiding our </head>/<body ... > boundary\n    // within <plaintext> capturing element. To construct source DOM, we need to rejoin\n    // head and body content, iterate through it to find head/body boundary and expose\n    // opening <body ... > tag as a string.\n\n    // Consume comments without grouping to avoid catching\n    // <body> inside a comment, common with IE conditional comments.\n    // (using a \"new RegExp\" here because in Android 2.3 when you use a global\n    // match using a RegExp literal, the state is incorrectly cached).\n    var bodySnatcher = new RegExp('<!--(?:[\\\\s\\\\S]*?)-->|(<\\\\/head\\\\s*>|<body[\\\\s\\\\S]*$)', 'gi');\n\n    //Fallback for absence of </head> and <body>\n    var rawHTML = captured.bodyContent = captured.headContent + captured.bodyContent;\n    captured.headContent = '';\n\n    // Search rawHTML for the head/body split.\n    for (var match; match = bodySnatcher.exec(rawHTML); match) {\n        // <!-- comment --> . Skip it.\n        if (!match[1]) continue;\n\n        // Grab the contents of head\n        captured.headContent = rawHTML.slice(0, match.index);\n        // Parse the head content\n        var parsedHeadTag = (new RegExp('^[\\\\s\\\\S]*(<head(?:[^>\\'\"]*|\\'[^\\']*?\\'|\"[^\"]*?\")*>)([\\\\s\\\\S]*)$')).exec(captured.headContent);\n        if (parsedHeadTag) {\n            // if headContent contains an open head, then we know the tag was placed\n            // outside of the body\n            captured.headOpenTag = parsedHeadTag[1];\n            captured.headContent = parsedHeadTag[2];\n        }\n\n        // If there is a closing head tag\n        if (match[1][1] == '/') {\n            // Hit </head. Gather <head> innerHTML. Also, take trailing content,\n            // just in case <body ... > is missing or malformed\n            captured.bodyContent = rawHTML.slice(match.index + match[1].length);\n        } else {\n            // Hit <body. Gather <body> innerHTML.\n            // If we were missing a </head> before, now we can pick up everything before <body\n            captured.bodyContent = match[0];\n\n            // Find the end of <body ... >\n            var parseBodyTag = /^((?:[^>'\"]*|'[^']*?'|\"[^\"]*?\")*>)([\\s\\S]*)$/.exec(captured.bodyContent);\n\n            // Will skip this if <body was malformed (e.g. no closing > )\n            if (parseBodyTag) {\n                // Normal termination. Both </head> and <body> were recognized and split out\n                captured.bodyOpenTag = parseBodyTag[1];\n                captured.bodyContent = parseBodyTag[2];\n            }\n            break;\n        }\n    }\n    return captured;\n};\n\nCapture.isIOS8_0 = function() {\n    var IOS8_REGEX = /ip(hone|od|ad).*Version\\/8.0/i;\n\n    return IOS8_REGEX.test(window.navigator.userAgent);\n};\n\n/**\n * This is a feature detection function to determine if you\n * can construct body using innerHTML. In iOS8, setting\n * innerHTML on body seems to break if you have forms.\n * If you have forms in the page which are siblings,\n * the second sibling ends up becoming a child element\n * of the first sibling.\n */\nCapture.isSetBodyInnerHTMLBroken = function(){\n    var doc = document.implementation.createHTMLDocument(\"\");\n    var bodyEl = doc.documentElement.lastChild;\n    if (!bodyEl) {\n        return false;\n    }\n    bodyEl.innerHTML = '<form></form><form></form>';\n    if (bodyEl.childNodes && bodyEl.childNodes.length === 1) {\n        return true;\n    }\n    return false;\n};\n\n/**\n * iOS 8.0 has a bug where dynamically switching the viewport (by swapping the\n * viewport meta tag) causes the viewport to automatically scroll. When\n * capturing, the initial document never has an active meta viewport tag.\n * Then, the rendered document injects one causing the aforementioned scroll.\n *\n * Create a meta viewport tag that we inject into the page to force the page to\n * scroll before anything is rendered in the page (this code should be called\n * before document.open!)\n *\n * JIRA: https://mobify.atlassian.net/browse/GOLD-883\n * Open Radar: http://www.openradar.me/radar?id=5516452639539200\n * WebKit Bugzilla: https://bugs.webkit.org/show_bug.cgi?id=136904\n */\nCapture.ios8_0ScrollFix = function(doc, callback) {\n    // Using `getElementsByTagName` here because grabbing head using\n    // `document.head` will throw exceptions in some older browsers (iOS 4.3).\n    var head = doc.getElementsByTagName('head');\n    // Be extra safe and guard against `head` not existing.\n    if (!head.length) {\n        return;\n    }\n    var head = head[0];\n\n    var meta = document.createElement('meta');\n    meta.setAttribute('name', 'viewport');\n    meta.setAttribute('content', 'width=device-width');\n    head.appendChild(meta);\n\n    if (callback) {\n        // Wait two paints for the meta viewport tag to take effect. This is\n        // required for this fix to work, but guard against it being undefined\n        // anyway just in case.\n        if (window.requestAnimationFrame) {\n            window.requestAnimationFrame(function() {\n                window.requestAnimationFrame(callback);\n            });\n        }\n        else {\n            callback();\n        }\n    }\n};\n\n/**\n * Grab the captured document and render it\n */\nCapture.prototype.restore = function(inject) {\n    var self = this;\n\n    Utils.waitForReady(document, function() {\n        self.render(self.all(inject));\n    });\n};\n\n/**\n * Grab fragment strings and construct DOM fragments\n * returns htmlEl, headEl, bodyEl, doc\n */\nCapture.prototype.createDocumentFragments = function() {\n    var docFrags = {};\n    var doc = docFrags.capturedDoc = document.implementation.createHTMLDocument(\"\");\n    var htmlEl = docFrags.htmlEl = doc.documentElement;\n    var headEl = docFrags.headEl = htmlEl.firstChild;\n    var bodyEl = docFrags.bodyEl = htmlEl.lastChild;\n\n    // Reconstruct html, body, and head with the same attributes as the original document\n    Capture.cloneAttributes(this.htmlOpenTag, htmlEl);\n    Capture.cloneAttributes(this.headOpenTag, headEl);\n    Capture.cloneAttributes(this.bodyOpenTag, bodyEl);\n\n    var disabledBodyContent = Capture.disable(this.bodyContent, this.prefix);\n    // Set innerHTML on body (if the browser is capable of doing so).\n    // If not, set innerHTML on a div and copy children elements into body.\n    if (!Capture.isSetBodyInnerHTMLBroken()) {\n        // Set innerHTML of new source DOM body\n        bodyEl.innerHTML = disabledBodyContent;\n    } else {\n        Capture.setElementContentFromString(bodyEl, disabledBodyContent);\n    }\n\n    // In Safari 4/5 and iOS 4.3, there are certain scenarios where elements\n    // in the body (ex \"meta\" in \"noscripts\" tags) get moved into the head,\n    // which can cause issues with certain websites (for example, if you have\n    // a meta refresh tag inside of a noscript tag)\n    var heads = doc.querySelectorAll('head');\n    if (heads.length > 1) {\n        while (heads[1].hasChildNodes()) {\n            heads[1].removeChild(heads[1].lastChild);\n        }\n    }\n\n    var disabledHeadContent = Capture.disable(this.headContent, this.prefix);\n    // On FF4, iOS 4.3, and potentially other browsers, you cannot modify <head>\n    // using innerHTML. In that case, do a manual copy of each element\n    try {\n        headEl.innerHTML = disabledHeadContent;\n    } catch (e) {\n        var title = headEl.getElementsByTagName('title')[0];\n        title && headEl.removeChild(title);\n        Capture.setElementContentFromString(headEl, disabledHeadContent);\n    }\n\n    return docFrags;\n};\n\n/**\n * Returns an HTML representation of the captured DOM with resources enabled.\n * (escapedHTMLString remains for backwards compatibility)\n */\nCapture.prototype.enabledHTMLString = Capture.prototype.escapedHTMLString = function() {\n    var doc = this.capturedDoc;\n    var html = Capture.enable(Utils.outerHTML(doc.documentElement), this.prefix);\n    var htmlWithDoctype = this.doctype + html;\n    return htmlWithDoctype;\n};\n\n/**\n * Rewrite the document with a new html string\n */\nCapture.prototype.render = function(htmlString) {\n    var enabledHTMLString;\n    if (!htmlString) {\n        enabledHTMLString = this.enabledHTMLString();\n    } else {\n        enabledHTMLString = Capture.enable(htmlString, this.prefix);\n    }\n\n    var doc = this.sourceDoc;\n\n    // Set capturing state to false so that the user main code knows how to execute\n    if (window.Mobify) window.Mobify.capturing = false;\n\n    var write = function() {\n        // Asynchronously render the new document\n        setTimeout(function(){\n            doc.open(\"text/html\", \"replace\");\n            doc.write(enabledHTMLString);\n            doc.close();\n        });\n    };\n    \n    if (Capture.isIOS8_0()) {\n        Capture.ios8_0ScrollFix(document, write);\n    } else {\n        write();\n    }\n};\n\n/**\n * Get the captured document\n */\nCapture.prototype.getCapturedDoc = function(options) {\n    return this.capturedDoc;\n};\n\nCapture.getMobifyLibrary = function(doc) {\n    var doc = doc || document;\n    var mobifyjsScript = doc.getElementById(\"mobify-js\");\n\n    // v6 tag backwards compatibility change\n    if (!mobifyjsScript) {\n        mobifyjsScript = doc.getElementsByTagName(\"script\")[0];\n        mobifyjsScript.id = \"mobify-js\";\n        mobifyjsScript.setAttribute(\"class\", \"mobify\");\n    }\n\n    return mobifyjsScript;\n};\n\n/**\n * Grabs the postload function/src/script if it exists\n */\nCapture.getPostload = function(doc) {\n    var doc = doc || document;\n    var postloadScript = undefined;\n\n    // mainExecutable is used for backwards compatibility purposes\n    var tagOptions = window.Mobify.Tag && window.Mobify.Tag.options && window.Mobify.Tag.getOptions(Mobify.Tag.options) || {};\n    var postload = (tagOptions.post && tagOptions.post.toString()) || window.Mobify.mainExecutable;\n    if (postload) {\n        // Checks for main executable string on Mobify object and creates a script\n        // out of it\n        postloadScript = document.createElement('script');\n        postloadScript.innerHTML = \"var postload = \" + postload + \"; postload();\";\n        postloadScript.id = 'postload';\n        postloadScript.setAttribute(\"class\", \"mobify\");\n    } else {\n        // Older tags used to insert the main executable by themselves. \n        postloadScript = doc.getElementById(\"main-executable\");\n    }\n    return postloadScript;\n}\n\n/**\n * Insert Mobify scripts back into the captured doc\n * in order for the library to work post-document.write\n */\nCapture.insertMobifyScripts = function(sourceDoc, destDoc) {\n    // After document.open(), all objects will be removed.\n    // To provide our library functionality afterwards, we\n    // must re-inject the script.\n    var mobifyjsScript = Capture.getMobifyLibrary(sourceDoc);\n\n    var head = destDoc.head || destDoc.getElementsByTagName('head')[0];\n    if (!head) {\n        return;\n    }\n\n    // If main script exists, re-inject it.\n    var mainScript = Capture.getPostload(sourceDoc);\n    if (mainScript) {\n        // Since you can't move nodes from one document to another,\n        // we must clone it first using importNode:\n        // https://developer.mozilla.org/en-US/docs/DOM/document.importNode\n        var mainClone = destDoc.importNode(mainScript, false);\n        if (!mainScript.src) {\n            mainClone.innerHTML = mainScript.innerHTML;\n        }\n        head.insertBefore(mainClone, head.firstChild);\n    }\n    // reinject mobify.js file\n    var mobifyjsClone = destDoc.importNode(mobifyjsScript, false);\n    head.insertBefore(mobifyjsClone, head.firstChild);\n};\n\n/**\n * Render the captured document\n */\nCapture.prototype.renderCapturedDoc = function(options) {\n    // Insert the mobify scripts back into the captured doc\n    Capture.insertMobifyScripts(this.sourceDoc, this.capturedDoc);\n\n    // Inject timing point (because of blowing away objects on document.write)\n    // if it exists\n    if (window.Mobify && window.Mobify.points) {\n        var body = this.bodyEl;\n        var date = this.capturedDoc.createElement(\"div\");\n        date.id = \"mobify-point\";\n        date.setAttribute(\"style\", \"display: none;\")\n        date.innerHTML = window.Mobify.points[0];\n        body.insertBefore(date, body.firstChild);\n    }\n\n    this.render();\n};\n\n/**\n * patchAnchorLinks\n *\n * Anchor Links `<a href=\"#foo\">Link</a>` are broken on Firefox.\n * We provide a function that patches, but it does break\n * actually changing the URL to show \"#foo\".\n * \n */\nCapture.patchAnchorLinks = patchAnchorLinks;\n\nreturn Capture;\n\n}));\n\n",
    "define('adaptivejs/adaptive',[\n    '$',\n    'adaptivejs/defaults',\n    'adaptivejs/logger',\n    'adaptivejs/utils',\n    'mobifyjs/capture'\n], function($, Defaults, Logger, Utils, Capture) {\n\n    // Backwards compatibility fix needed for v6 tag\n    window.Mobify = window.Mobify || {};\n    window.Mobify.api = true;\n\n    // Instantiate the Adaptive object\n    var Adaptive = window.Adaptive = window.Adaptive || {};\n\n    /**\n    * Restore the original document when capturing\n    */\n    Adaptive.restore = function() {\n        // Make sure we don't render the current doc before restoring\n        Adaptive.disabled = true;\n\n        // Inject Mobify analytics script to track errors\n        var ajsScript = Utils.getAjs(Defaults.projectName);\n        Adaptive.capture.restore(ajsScript);\n        window.Mobify.capturing = false;\n    };\n\n    /**\n    * Set mobify-path= on the cookie and reload the page so that tag falls\n    * through to the original page.  Disables adaptation for subsequent requests\n    *\n    * url: Optional url to redirect to after opting out.\n    */\n    Adaptive.disable = function(url) {\n        document.cookie = 'mobify-path=; path=/;';\n\n        var capturing = window.Mobify && window.Mobify.capturing || false;\n\n        if (!capturing) {\n            if (url) {\n                window.location = url;\n                return;\n            }\n\n            // Use window.reload in webkit only since it doesn't work in Firefox\n            if (/webkit/i.test(window.navigator.userAgent)) {\n                // Clear the mobify-overide hash before reloading (if we don't\n                // remove the mobify-override, it will force us back into\n                // preview mode again)\n                if (Utils.isDebug()) {\n                    window.location.hash = '';\n                }\n                window.location.reload(true);\n            } else {\n                window.location = window.location.pathname;\n            }\n\n            return;\n        }\n\n        Adaptive.restore();\n    };\n\n    // Method for initializing 'Adaptive'\n    // callback(capturedDocument)\n    Adaptive.init = function(callback) {\n        var capturing = window.Mobify && window.Mobify.capturing || false;\n\n        if (capturing) {\n            // Setup the logger and initialize the start time\n\n            Logger.init({start: Mobify.points[0], debug: Utils.isDebug()});\n            Logger.addTimingPoint('Starting capture of original document');\n\n            // Grab reference to a newly created document\n            Capture.init(function(capture) {\n                // Store the 'capture' object on 'Adaptive' for later use when\n                // rendering\n                Logger.addTimingPoint('Capture is complete');\n                Adaptive.capture = capture;\n                var buildScript = capture.capturedDoc.getElementsByTagName('script')[0];\n                if (buildScript && /adaptive(\\.min)?\\.js/.test(buildScript.getAttribute('x-src'))) {\n                    buildScript.parentNode.removeChild(buildScript);\n                }\n                // Bind selector engine to the captured document\n                $.attachDocument(capture.capturedDoc);\n                callback(capture.capturedDoc);\n            });\n        }\n        else {\n            // Expose Almond to UI scripts\n            Adaptive.AMD = {};\n            Adaptive.AMD.require = require;\n            Adaptive.AMD.define = define;\n            // Expose $ for front-end scripts\n            Adaptive.$ = $;\n\n            // We're not capturing. Bind selector library to original document\n            $.attachDocument(document);\n            // Adds logging points for Load and DOMContentLoaded events\n            Logger.setDebugger(Utils.isDebug());\n            Logger.addTimingPoint('Rendering Done');\n            Logger.addDOMContentListener();\n            Logger.addOnLoadListener(function() {\n                Logger.logTimingPoints();\n            });\n        }\n    };\n\n    Adaptive.renderPage = function(htmlStr) {\n        if (!Adaptive.disabled) {\n            if (!Adaptive.capture) {\n                throw 'We are using Capturing, but there is no capture object to render';\n            }\n            Logger.addTimingPoint('Rendering Start');\n            Adaptive.capture.render(htmlStr);\n        }\n    };\n\n    return Adaptive;\n});\n\n",
    "/*\n * A module for evaluating function and DOM element based template rendering\n * contexts.\n */\n/*jshint forin: false */\n\ndefine('adaptivejs/context',[\n    'adaptivejs/utils',\n    'adaptivejs/logger'\n], function(Utils, Logger) {\n    var Context = {};\n\n    var isPrimitive = function(value) {\n        var type = typeof value;\n        return type !== 'object' && type !== 'function';\n    };\n\n    var isArrayLike = function(obj) {\n        var isArray = Object.prototype.toString.call(obj) === '[object Array]';\n        return isArray || obj.hasOwnProperty('length');\n    };\n\n    /**\n     *  Recursively evaluates keys of the given context until we get\n     *  a DOM node, DOM element, jQuery/Zepto object, or a primitive.\n     */\n    /* jshint ignore:start */\n    Context.process = function(ogContext) {\n        var errors = {};\n        var walkContext = function(context) {\n            var result;\n            var value;\n\n            if (context === null) {\n                return undefined;\n            }\n\n            // Return DOM nodes, DOM elements, and primitives\n            if (Utils.isDOMLike(context) || isPrimitive(context)) {\n                return context;\n            }\n\n            // invoke functions\n            if (typeof context === 'function') {\n                result = walkContext(context(ogContext));\n\n                // Primatives or complex objects which we don't care\n                // to break into\n                return result;\n            }\n\n            if (isArrayLike(context)) {\n                result = [];\n                for (var i = 0, len = context.length; i < len; i++) {\n                    result.push(walkContext(context[i]));\n                }\n                return result;\n            }\n\n            // We know we are dealing with an object now. Lets grab the object to be\n            //  evaluated and replace context with an empty object to fill in with the results\n            //  of evaluating the object.\n            for (var key in context) {\n                if (!context.hasOwnProperty(key)) {\n                    continue;\n                }\n\n                value = context[key];\n                try {\n                    Logger.addTimingPoint(key, {namespace: 'Evaluating View'});\n                    Logger.increaseStack();\n                    context[key] = walkContext(value);\n\n                    // Warn if the key is undefined\n                    // Keys should always be assigned some value\n                    if (context[key] === undefined) {\n                        Logger.log(key + ' key is undefined. Context keys should always return a value', 'warn');\n                    }\n                    Logger.decreaseStack();\n                }\n                catch (e) {\n                    console.error('Error evaluating key \"' + key + '\". ' + e.stack);\n                    context[key] = undefined;\n                    errors[key] = e;\n                }\n            }\n\n            return context;\n        };\n\n        var resultContext = walkContext(ogContext);\n\n        // If there were errors, add them to the resulting context\n        if (Object.keys(errors).length) {\n            resultContext.errors = errors;\n        }\n        return resultContext;\n    };\n    /* jshint ignore:end */\n\n    return Context;\n\n});\n\n",
    "/*jshint forin: false */\n\ndefine('adaptivejs/view',[\n    'adaptivejs/context',\n    'adaptivejs/logger',\n    'adaptivejs/utils'\n], function(Context, Logger, Utils) {\n\n    var View = {};\n\n    /**\n     *  Executes the passed function, but wraps in a try/catch.\n     */\n    var safeExecFunction = function(func, errPrefix, params) {\n        errPrefix = errPrefix || '';\n        params = params || [];\n        try {\n            func.apply(this, params);\n        } catch (e) {\n            console.error(errPrefix, e.stack);\n        }\n    };\n\n    /**\n     *  Adds any context from partials to the views context.\n     *  Tack on include preProcess methods to the list of methods to run.\n     */\n    var processIncludes = function(includes, includeMethods, context) {\n        // tmp array to preserve preProcess execution order\n        var preTemp = [];\n        var postTemp = [];\n        var tempContext = {};\n        for (var key in includes){\n            // Don't add include if a child already added it\n            if (!includes.hasOwnProperty(key) || context.hasOwnProperty(key)) {\n                continue;\n            }\n\n            var include = includes[key];\n\n            // Add includes to tempContext which we extend to preserve order\n            tempContext[key] = include.context;\n            include.preProcess && preTemp.push({'key': key, 'function': include.preProcess});\n            include.postProcess && postTemp.push({'key': key, 'function': include.postProcess});\n        }\n\n        // Add preProcess methods to the start of the list so they run in order\n        includeMethods.preProcess = preTemp.concat(includeMethods.preProcess);\n        includeMethods.postProcess = postTemp.concat(includeMethods.postProcess);\n\n        // Add includes to the context\n        return Utils.extend(tempContext, context);\n    };\n\n    /**\n     *  Evaluates and returns a views context by:\n     *  1. Extend context of all includes onto the view\n     *  2. Extend context of any parent views onto the context\n     *  3. Call preProcess method of all includes which define it\n     *  4. Call parent views proProcess, unless the child view overrides it\n     *  5. Evaluating all the context keys\n     *  6. Call postProcess method of all includes which define it\n     *  7. Call parent views postProcess, unless the view overrides it\n     */\n    /* jshint ignore:start */\n    View.evaluateContext = function(view, defaultContext) {\n        // Used to store preProcess functions for later execution\n        var includeMethods = {\n            preProcess: [],\n            postProcess: []\n        };\n        var includes = {};\n        var error;\n        var i;\n\n        // Build up view\n        var tempContext = this.compileContext(view, defaultContext, includes, includeMethods);\n\n        // Call all include preProcess functions in correct order\n        for (i = 0; i < includeMethods.preProcess.length; i++) {\n            var preProcess = includeMethods.preProcess[i];\n            error = 'Error calling preProcess from' + preProcess.key;\n\n            tempContext = safeExecFunction(preProcess['function'], error, [tempContext]) || tempContext;\n            Logger.addTimingPoint(preProcess.key + 'PreProcess', {namespace: 'Evaluating View'});\n        }\n\n        // Call preProcess from the view, or it's closest ancestor\n        var viewPreProcess = getClosestProperty(view, 'preProcess');\n        if (viewPreProcess) {\n            tempContext = safeExecFunction(viewPreProcess, 'Error calling views preProcess', [tempContext]) || tempContext;\n            Logger.addTimingPoint('viewPreProcess', {namespace: 'Evaluating View'});\n        }\n\n        // Evaluate context\n        tempContext = Context.process(tempContext);\n\n        // Call all include postProcess functions\n        for (i = 0; i < includeMethods.postProcess.length; i++) {\n            var postProcess = includeMethods.postProcess[i];\n            error = 'Error calling postProcess from' + postProcess.key;\n\n            tempContext = safeExecFunction(postProcess['function'], error, [tempContext]) || tempContext;\n            Logger.addTimingPoint(postProcess.key + 'PostProcess', {namespace: 'Evaluating View'});\n        }\n\n        // Call postProcess from the view, or it's closest ancestor\n        var viewPostProcess = getClosestProperty(view, 'postProcess');\n        if (viewPostProcess){\n            tempContext = safeExecFunction(viewPostProcess, 'Error calling views postProcess', [tempContext]) || tempContext;\n            Logger.addTimingPoint('viewPostProcess', {namespace: 'Evaluating View'});\n        }\n\n        Logger.addTimingPoint('View processed');\n        Logger.logCollapsed('Evaluated Context', tempContext);\n        return tempContext;\n    };\n    /* jshint ignore:end */\n\n    /**\n     *  Builds up the structure of the views context, inherriting from parents\n     *  Doesn't evaluate any functions.\n     */\n    View.compileContext = function(view, context, includes, includeMethods) {\n        var parentView = view.extend;\n\n        // We use this to build the context in the correct order\n        var tempContext = context || {};\n\n        // Add all includes to the context\n        if (view.includes) {\n            tempContext = processIncludes(view.includes, includeMethods, tempContext);\n        }\n\n        // If there is a parent view, extend it.\n        if (parentView) {\n            // Remove keys that will be overridden to preserve order\n            for (var key in parentView.context) {\n                if (view.context.hasOwnProperty(key)) {\n                    delete parentView.context[key];\n                }\n            }\n\n            tempContext = View.compileContext(view.extend, tempContext, includes, includeMethods);\n        }\n\n        // Add the views context after all the previous context keys\n        // for proper evaluation order\n        tempContext = Utils.extend(tempContext, view.context);\n\n        return tempContext;\n\n    };\n\n    /**\n     *  Finds the closest ancestor to the view with the given property.\n     *  Returns that property.\n     */\n    var getClosestProperty = function(view, property) {\n        if (!view.extend && !view[property]){\n            return undefined;\n        }\n        return view[property] || getClosestProperty(view.extend, property);\n    };\n\n    return View;\n\n});\n\n",
    "require([\n    'router',\n    'adaptivejs/adaptive',\n    'adaptivejs/view',\n    'adaptivejs/utils',\n    'adaptivejs/defaults'\n],\nfunction(router, Adaptive, View, Utils, Defaults) {\n\n    Adaptive.init(function(capturedDocument) {\n        try {\n            var view = router.resolve(capturedDocument);\n            if (!view) {\n                console.error('No routes were matched. Rendering original document.');\n                Adaptive.restore();\n                return;\n            }\n\n            // Make any changes to defaultContext here, then add it to view.context\n            var defaultContext = Defaults.getContext();\n\n            // Build up context of the main view\n            var resultContext = View.evaluateContext(view, defaultContext);\n\n            // Feed context to template and render result\n            view.template(resultContext, function(err, out) {\n                Adaptive.renderPage(out);\n            });\n        } catch (e) {\n            console.error(e.stack);\n            Adaptive.restore();\n        }\n    });\n\n}, undefined, true);\n// relPath, forceSync\n;\ndefine(\"main\", function(){});\n\n"
  ]
}